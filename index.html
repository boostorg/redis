<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aedis: Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aedis.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="6">
 <tbody>
 <tr>
  <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">Aedis 1.1.1</font> &#160; <br> A redis client designed for performance and scalability </td>
  <td style="width:100%">         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1">Overview</a><ul><li class="level2"><a href="#autotoc_md2">Connection</a></li>
<li class="level2"><a href="#autotoc_md3">Reconnect</a></li>
<li class="level2"><a href="#autotoc_md4">Timeouts</a></li>
<li class="level2"><a href="#autotoc_md5">Installation</a></li>
<li class="level2"><a href="#autotoc_md6">Examples</a></li>
<li class="level2"><a href="#autotoc_md7">API Reference</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md8">Requests</a><ul><li class="level2"><a href="#autotoc_md9">Serialization</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md10">Responses</a><ul><li class="level2"><a href="#autotoc_md11">Null</a></li>
<li class="level2"><a href="#autotoc_md12">Transactions</a></li>
<li class="level2"><a href="#autotoc_md13">Deserialization</a></li>
<li class="level2"><a href="#autotoc_md14">The general case</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md15">Why Aedis</a><ul><li class="level2"><a href="#autotoc_md16">Redis-plus-plus</a></li>
<li class="level2"><a href="#autotoc_md17">Benchmark: Echo server</a><ul><li class="level3"><a href="#autotoc_md18">Without Redis</a></li>
<li class="level3"><a href="#autotoc_md19">With Redis</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md20">Changelog</a><ul><li class="level2"><a href="#autotoc_md21">v1.1.0</a></li>
<li class="level2"><a href="#autotoc_md22">v1.0.0</a></li>
<li class="level2"><a href="#autotoc_md23">v0.3.0</a></li>
<li class="level2"><a href="#autotoc_md24">v0.2.1</a></li>
<li class="level2"><a href="#autotoc_md25">v0.2.0</a></li>
<li class="level2"><a href="#autotoc_md26">v0.1.2</a></li>
<li class="level2"><a href="#autotoc_md27">v0.1.1</a></li>
<li class="level2"><a href="#autotoc_md28">v0.1.0</a></li>
<li class="level2"><a href="#autotoc_md29">v0.0.1</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md30">Acknowledgement</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p >Aedis is a high-level <a href="https://redis.io/">Redis</a> client library built on top of <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Asio</a>. Some of its distinctive features are</p>
<ul>
<li>Support for the latest version of the Redis communication protocol <a href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>.</li>
<li>Support for STL containers, TLS and Redis sentinel.</li>
<li>Serialization and deserialization of your own data types.</li>
<li>Healthy checks, back pressure and low latency.</li>
</ul>
<p >In addition to that, Aedis hides most of the low-level Asio code away from the user, which in the majority of the use cases will interact with only three library entities</p>
<ul>
<li><code><a class="el" href="classaedis_1_1connection.html" title="A connection to the Redis server.">aedis::connection</a></code>: A healthy long-lasting connection to the Redis server.</li>
<li><code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code>: A container of Redis commands.</li>
<li><code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code>: Adapts user data structures like STL containers to receive Redis responses.</li>
</ul>
<p >Let us see how this works in more detail.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Connection</h2>
<p >The code below will establish a connection with a Redis server where users can send commands (see <a class="el" href="intro_8cpp_source.html">intro.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   net::io_context ioc;</div>
<div class="line">   <a class="code hl_class" href="classaedis_1_1connection.html">connection</a> conn{ioc};</div>
<div class="line"> </div>
<div class="line">   conn.<a class="code hl_function" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558">async_run</a>({<span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>}, {}, [](<span class="keyword">auto</span> ec) { ... });</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Pass conn to other operations ...</span></div>
<div class="line"> </div>
<div class="line">   ioc.run();</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1connection_html"><div class="ttname"><a href="classaedis_1_1connection.html">aedis::connection</a></div><div class="ttdoc">A connection to the Redis server.</div><div class="ttdef"><b>Definition:</b> <a href="connection_8hpp_source.html#l00033">connection.hpp:36</a></div></div>
<div class="ttc" id="aclassaedis_1_1connection_html_ab13b8c7ea4e3c41faec732e048188558"><div class="ttname"><a href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558">aedis::connection::async_run</a></div><div class="ttdeci">auto async_run(endpoint ep, timeouts ts=timeouts{}, CompletionToken token=CompletionToken{})</div><div class="ttdoc">Starts communication with the Redis server asynchronously.</div><div class="ttdef"><b>Definition:</b> <a href="connection_8hpp_source.html#l00140">connection.hpp:140</a></div></div>
</div><!-- fragment --><p >Requests on the other hand can be sent at any time, regardless of whether before or after a connection was established. For example, the code below sends the <code>PING</code> and <code>QUIT</code> commands, waits for the response and exits</p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; ping(std::shared_ptr&lt;connection&gt; conn)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Request</span></div>
<div class="line">   request req;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;PING&quot;</span>, <span class="stringliteral">&quot;some message&quot;</span>);</div>
<div class="line">   req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Response</span></div>
<div class="line">   std::tuple&lt;std::string, aedis::ignore&gt; resp;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Execution</span></div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Response: &quot;</span> &lt;&lt; std::get&lt;0&gt;(resp) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__high-level-api_html_gac56bb1a8df93445853a4b9dae2d97b6e"><div class="ttname"><a href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">aedis::adapt</a></div><div class="ttdeci">auto adapt(std::size_t max_read_size=(std::numeric_limits&lt; std::size_t &gt;::max)()) noexcept</div><div class="ttdoc">Creates an adapter that ignores responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00199">adapt.hpp:199</a></div></div>
</div><!-- fragment --><p >The general structure about how to send commands is evident from the code above</p>
<ul>
<li>Create a <code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code> object and add commands.</li>
<li>Declare responses as elements of a <code>std::tuple</code>.</li>
<li>Execute the request.</li>
</ul>
<p >Multiple calls to <code><a class="el" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> are synchronized automatically so that different operations (or coroutines) don't have to be aware of each other. Server side pushes can be received on the same connection object that is being used to execute commands, for example (see <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>)</p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; receive_pushes(std::shared_ptr&lt;connection&gt; conn)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">for</span> (std::vector&lt;node&lt;std::string&gt;&gt; resp;;) {</div>
<div class="line">      <span class="keyword">co_await</span> conn-&gt;async_receive_push(<a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line">      <span class="comment">// Process the push in resp.</span></div>
<div class="line">      resp.clear();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Users should make sure any server pushes sent by the server are consumed, otherwise the connection will eventually timeout.</dd></dl>
<h2><a class="anchor" id="autotoc_md3"></a>
Reconnect</h2>
<p >The <code><a class="el" href="classaedis_1_1connection.html" title="A connection to the Redis server.">aedis::connection</a></code> class also supports reconnection. In the simplest scenario, after a connection lost users will want to reconnect to the same server, the loop below shows how to do it</p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; reconnect(std::shared_ptr&lt;connection&gt; conn)</div>
<div class="line">{</div>
<div class="line">   net::steady_timer timer{<span class="keyword">co_await</span> net::this_coro::executor};</div>
<div class="line">   <span class="keywordflow">for</span> (;;) {</div>
<div class="line">      boost::system::error_code ec;</div>
<div class="line">      <span class="keyword">co_await</span> conn-&gt;async_run({<span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>}, {}, net::redirect_error(net::use_awaitable, ec));</div>
<div class="line">      conn-&gt;reset_stream();</div>
<div class="line">      timer.expires_after(std::chrono::seconds{1});</div>
<div class="line">      <span class="keyword">co_await</span> timer.async_wait();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p> more complex scenarios, like performing a failover with sentinel can be found in the examples. To aid proper failover, calls to <code><a class="el" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> won't automatically fail as a result of connection lost, rather, they will remain suspended until a new connection is established, once that happens all awaiting requests will be sent automatically. This behaviour can be changed per request by setting on the <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a6a4133593d69da73da3df0e8dbab2695" title="If set to true, requests started with connection::async_exe will fail either if the connection is los...">aedis::resp3::request::config::close_on_connection_lost</a></code> or by calling <code><a class="el" href="classaedis_1_1connection.html#a114105726f94e52215c1ea2a9f8600d8" title="Cancel operations.">connection::cancel()</a></code> with <code>connection::operation::exec</code> which will cause all pending requests to be canceled.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Timeouts</h2>
<p >Aedis high-level API provides built-in support for most timeouts users might need. For example, the <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">aedis::connection::async_run</a></code> member function performs the following operations on behalf of the user</p>
<ul>
<li>Resolves Redis address.</li>
<li>Connects to the endpoint.</li>
<li>TLS handhshake (for TLS endpoints).</li>
<li>RESP3 handshake, authentication and role check.</li>
<li>Keeps sending PING commands to check for unresponsive servers.</li>
<li>Keeps reading from the socket to handle server pushes and command responses.</li>
<li>Keeps writing requests as it becomes possible e.g. after last response has arrived.</li>
</ul>
<p >To control the timeout-behaviour of the operations above users must create a <code><a class="el" href="classaedis_1_1connection.html#structaedis_1_1connection_1_1timeouts" title="Connection configuration parameters.">aedis::connection::timeouts</a></code> object and pass it to as argument to the <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">aedis::connection::async_run</a></code> member function (or use the suggested defaults).</p>
<p >Another related topic is the cancellation of <code><a class="el" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff" title="Executes a command on the Redis server asynchronously.">aedis::connection::async_exec</a></code>. With the introduction of awaitable operators in Asio it is very simple implement timeouts either on individual or on a group of operations, for example, users may be tempted in writing code like</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_exec(...) || timer.async_wait(...))</div>
</div><!-- fragment --><p >The problem with this approach in Aedis is twofold</p>
<ul>
<li>Aedis has a buil-in healthy check that sends <code>PING</code> commands and checks whether responses are being received on time. Since user commands use the same queue as the built-in <code>PING</code>, they are also subjected to the idle timeout, rendering cancellation like above unnecessary.</li>
<li>To improve performance Redis encourages the use of pipelines, where many requests are sent in a single chunk to the server. In this scenario it is harder to cancel individual operations without causing all other (independent) requests in the same pipeline to fail too.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Installation</h2>
<p >Download the latest Aedis release from github</p>
<div class="fragment"><div class="line">$ wget https:<span class="comment">//github.com/mzimbres/aedis/releases/download/v1.1.0/aedis-1.1.0.tar.gz</span></div>
</div><!-- fragment --><p >and unpack in your preferred location. Aedis is a header only library, so you can starting using it. For that include the following header</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;aedis/src.hpp&gt;</span></div>
</div><!-- fragment --><p> in no more than one source file in your applications (see <a class="el" href="intro_8cpp_source.html">intro.cpp</a> for example). To build the examples and run the tests cmake is also supported</p>
<div class="fragment"><div class="line">$ BOOST_ROOT=/opt/boost_1_79_0/ cmake</div>
<div class="line">$ make</div>
<div class="line">$ make test</div>
</div><!-- fragment --><p >These are the requirements for using Aedis</p>
<ul>
<li>Boost 1.79 or greater.</li>
<li>C++17. Some examples require C++20 with coroutine support.</li>
<li>Redis 6 or higher. Optionally also redis-cli and Redis Sentinel.</li>
</ul>
<p >The following compilers are supported</p>
<ul>
<li>Tested with gcc: 10, 11, 12.</li>
<li>Tested with clang: 11, 13, 14.</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Examples</h2>
<p >Users are encouraged to skim over the examples below before proceeding to the next sections</p>
<ul>
<li><a class="el" href="intro_8cpp_source.html">intro.cpp</a>: The Aedis hello-world program. It sends one command to Redis and quits the connection.</li>
<li><a class="el" href="intro__tls_8cpp_source.html">intro_tls.cpp</a>: Same as <a class="el" href="intro_8cpp_source.html">intro.cpp</a> but over TLS.</li>
<li><a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a>: Synchronous version of <a class="el" href="intro_8cpp_source.html">intro.cpp</a>.</li>
<li><a class="el" href="containers_8cpp_source.html">containers.cpp</a>: Shows how to send and receive stl containers and how to use transactions.</li>
<li><a class="el" href="serialization_8cpp_source.html">serialization.cpp</a>: Shows how to serialize types using Boost.Json.</li>
<li><a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>: Shows how to implement pubsub that reconnects and resubscribes when the connection is lost.</li>
<li><a class="el" href="subscriber__sentinel_8cpp_source.html">subscriber_sentinel.cpp</a>: Same as <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a> but with failover with sentinels.</li>
<li><a class="el" href="echo__server_8cpp_source.html">echo_server.cpp</a>: A simple TCP echo server.</li>
<li><a class="el" href="chat__room_8cpp_source.html">chat_room.cpp</a>: A simple chat room.</li>
</ul>
<p ><a class="anchor" id="api-reference"></a></p>
<h2><a class="anchor" id="autotoc_md7"></a>
API Reference</h2>
<ul>
<li><a class="el" href="group__high-level-api.html">High-Level</a>: Recommend to all users</li>
<li><a class="el" href="group__low-level-api.html">Low-Level</a>: For users with needs yet to be imagined by the author.</li>
</ul>
<p >In the next sections we will see how to create requests and receive responses with more detail</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Requests</h1>
<p >Redis requests are composed of one of more Redis commands (in Redis documentation they are called <a href="https://redis.io/topics/pipelining">pipelines</a>). For example</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with variable length of arguments.</span></div>
<div class="line">req.push(<span class="stringliteral">&quot;SET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;some value&quot;</span>, value, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a list.</span></div>
<div class="line">std::list&lt;std::string&gt; list</div>
<div class="line">   {<span class="stringliteral">&quot;channel1&quot;</span>, <span class="stringliteral">&quot;channel2&quot;</span>, <span class="stringliteral">&quot;channel3&quot;</span>};</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but as an iterator range.</span></div>
<div class="line">req.push_range2(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, std::cbegin(list), std::cend(list));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a map.</span></div>
<div class="line">std::map&lt;std::string, mystruct&gt; map</div>
<div class="line">   { {<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>}</div>
<div class="line">   , {<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>}</div>
<div class="line">   , {<span class="stringliteral">&quot;key3&quot;</span>, <span class="stringliteral">&quot;value3&quot;</span>}};</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Sending a request to Redis is then performed with the following function</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p ><a class="anchor" id="serialization"></a></p>
<h2><a class="anchor" id="autotoc_md9"></a>
Serialization</h2>
<p >The <code>push</code> and <code>push_range</code> functions above work with integers e.g. <code>int</code> and <code>std::string</code> out of the box. To send your own data type defined a <code>to_bulk</code> function like this</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mystruct {</div>
<div class="line">   <span class="comment">// Example struct.</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a30ed6048af1b522f52d7e0e53eac4332">to_bulk</a>(std::string&amp; to, mystruct <span class="keyword">const</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">   std::string dummy = <span class="stringliteral">&quot;Dummy serializaiton string.&quot;</span>;</div>
<div class="line">   aedis::resp3::to_bulk(to, dummy);</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1resp3_1_1request_html_a30ed6048af1b522f52d7e0e53eac4332"><div class="ttname"><a href="classaedis_1_1resp3_1_1request.html#a30ed6048af1b522f52d7e0e53eac4332">aedis::resp3::request::to_bulk</a></div><div class="ttdeci">void to_bulk(Request &amp;to, boost::string_view data)</div><div class="ttdoc">Adds a bulk to the request.</div><div class="ttdef"><b>Definition:</b> <a href="request_8hpp_source.html#l00048">request.hpp:48</a></div></div>
</div><!-- fragment --><p >Once <code>to_bulk</code> is defined and accessible over ADL <code>mystruct</code> can be passed to the <code>request</code></p>
<div class="fragment"><div class="line">request req;</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, mystruct&gt; map {...};</div>
<div class="line"> </div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Example <a class="el" href="serialization_8cpp_source.html">serialization.cpp</a> shows how store json string in Redis.</p>
<p ><a class="anchor" id="responses"></a></p>
<h1><a class="anchor" id="autotoc_md10"></a>
Responses</h1>
<p >To read responses effectively, users must know their RESP3 type, this can be found in the Redis documentation for each command (<a href="https://redis.io/commands">https://redis.io/commands</a>). For example</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lpush   </td><td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lrange   </td><td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set   </td><td class="markdownTableBodyNone">Simple-string, null or blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/set">https://redis.io/commands/set</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">get   </td><td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/get">https://redis.io/commands/get</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">smembers   </td><td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hgetall   </td><td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a>   </td></tr>
</table>
<p >Once the RESP3 type of a given response is known we can choose a proper C++ data structure to receive it in. Fortunately, this is a simple task for most types. The table below summarises the options</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Possible C++ type   </th><th class="markdownTableHeadNone">Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple-string   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple-error   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blob-error   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><code>long long</code>, <code>int</code>, <code>std::size_t</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone"><code>double</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Null   </td><td class="markdownTableBodyNone"><code>std::optional&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::list</code>, <code>std::array</code>, <code>std::deque</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::set</code>, <code>std::unordered_set</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Push   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate   </td></tr>
</table>
<p >For example</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;RPUSH&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>, vec);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, map);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key4&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// hello</span></div>
<div class="line">   int,            <span class="comment">// rpush</span></div>
<div class="line">   int,            <span class="comment">// hset</span></div>
<div class="line">   std::vector&lt;T&gt;, <span class="comment">// lrange</span></div>
<div class="line">   std::map&lt;U, V&gt;, <span class="comment">// hgetall</span></div>
<div class="line">   std::string     <span class="comment">// quit</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="ttc" id="agroup__high-level-api_html_ga0d619e51ab37f7854e7218a061900820"><div class="ttname"><a href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a></div><div class="ttdeci">adapter::detail::ignore ignore</div><div class="ttdoc">Tag used to ignore responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00036">adapt.hpp:36</a></div></div>
</div><!-- fragment --><p >The tag <code>aedis::ignore</code> can be used to ignore individual elements in the responses. If the intention is to ignore the response to all commands in the request use <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">adapt()</a></code> </p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>());</div>
</div><!-- fragment --><p >Responses that contain nested aggregates or heterogeneous data types will be given special treatment later in <a class="el" href="index.html#the-general-case">The general case</a>. As of this writing, not all RESP3 types are used by the Redis server, which means in practice users will be concerned with a reduced subset of the RESP3 specification.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Null</h2>
<p >It is not uncommon for apps to access keys that do not exist or that have already expired in the Redis server, to deal with these cases Aedis provides support for <code>std::optional</code>. To use it, wrap your type around <code>std::optional</code> like this</p>
<div class="fragment"><div class="line">std::optional&lt;std::unordered_map&lt;T, U&gt;&gt; resp;</div>
<div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >Everything else stays the same.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Transactions</h2>
<p >To read the response to transactions we have to observe that Redis queues the commands as they arrive and sends the responses back to the user as an array, in the response to the <code>exec</code> command. For example, to read the response to the this request</p>
<div class="fragment"><div class="line">db.send(<span class="stringliteral">&quot;MULTI&quot;</span>);</div>
<div class="line">db.send(<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line">db.send(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, 0, -1);</div>
<div class="line">db.send(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>);</div>
<div class="line">db.send(<span class="stringliteral">&quot;EXEC&quot;</span>);</div>
</div><!-- fragment --><p >use the following response type</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>exec_resp_type = </div>
<div class="line">   std::tuple&lt;</div>
<div class="line">      std::optional&lt;std::string&gt;, <span class="comment">// get</span></div>
<div class="line">      std::optional&lt;std::vector&lt;std::string&gt;&gt;, <span class="comment">// lrange</span></div>
<div class="line">      std::optional&lt;std::map&lt;std::string, std::string&gt;&gt; <span class="comment">// hgetall</span></div>
<div class="line">   &gt;;</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// multi</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// get</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// lrange</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// hgetall</span></div>
<div class="line">   exec_resp_type, <span class="comment">// exec</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >Note that above we are not ignoring the response to the commands themselves but whether they have been successfully queued. For a complete example see <a class="el" href="containers_8cpp_source.html">containers.cpp</a>.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Deserialization</h2>
<p >As mentioned in <a class="el" href="index.html#serialization">serialization</a>, it is common to serialize data before sending it to Redis e.g. to json strings. For performance and convenience reasons, we may also want to deserialize it directly in its final data structure. Aedis supports this use case by calling a user provided <code>from_bulk</code> function while parsing the response. For example</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> from_bulk(mystruct&amp; obj, <span class="keywordtype">char</span> <span class="keyword">const</span>* p, std::size_t size, boost::system::error_code&amp; ec)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Deserializes p into obj.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >After that, you can start receiving data efficiently in the desired types e.g. <code>mystruct</code>, <code>std::map&lt;std::string, mystruct&gt;</code> etc.</p>
<p ><a class="anchor" id="the-general-case"></a></p>
<h2><a class="anchor" id="autotoc_md14"></a>
The general case</h2>
<p >There are cases where responses to Redis commands won't fit in the model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose responses don't have a fixed RESP3 type. Expecting an <code>int</code> and receiving a blob-string will result in error.</li>
<li>RESP3 aggregates that contain nested aggregates can't be read in STL containers.</li>
<li>Transactions with a dynamic number of commands can't be read in a <code>std::tuple</code>.</li>
</ul>
<p >To deal with these cases Aedis provides the <code>resp3::node</code> type, that is the most general form of an element in a response, be it a simple RESP3 type or an aggregate. It is defined like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;</div>
<div class="line"><span class="keyword">struct </span>node {</div>
<div class="line">   <span class="comment">// The RESP3 type of the data in this node.</span></div>
<div class="line">   <a class="code hl_enumeration" href="group__high-level-api.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">type</a> data_type;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The number of elements of an aggregate (or 1 for simple data).</span></div>
<div class="line">   std::size_t aggregate_size;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The depth of this node in the response tree.</span></div>
<div class="line">   std::size_t depth;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The actual data. For aggregate types this is always empty.</span></div>
<div class="line">   String value;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__high-level-api_html_gabdb6bdf6f96b4a7a91ed63d2324cef57"><div class="ttname"><a href="group__high-level-api.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">aedis::resp3::type</a></div><div class="ttdeci">type</div><div class="ttdoc">RESP3 data types.</div><div class="ttdef"><b>Definition:</b> <a href="type_8hpp_source.html#l00021">type.hpp:22</a></div></div>
</div><!-- fragment --><p >Any response to a Redis command can be received in a <code>std::vector&lt;node&lt;std::string&gt;&gt;</code>. The vector can be seen as a pre-order view of the response tree. Using it is no different than using other types</p>
<div class="fragment"><div class="line"><span class="comment">// Receives any RESP3 simple data type.</span></div>
<div class="line">node&lt;std::string&gt; resp;</div>
<div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Receives any RESP3 simple or aggregate data type.</span></div>
<div class="line">std::vector&lt;node&lt;std::string&gt;&gt; resp;</div>
<div class="line"><span class="keyword">co_await</span> db-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >For example, suppose we want to retrieve a hash data structure from Redis with <code>HGETALL</code>, some of the options are</p>
<ul>
<li><code>std::vector&lt;node&lt;std::string&gt;</code>: Works always.</li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all elements as string.</li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if you need the data as a <code>std::map</code>.</li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing serialized data. Avoids temporaries and requires <code>from_bulk</code> for <code>U</code> and <code>V</code>.</li>
</ul>
<p >In addition to the above users can also use unordered versions of the containers. The same reasoning also applies to sets e.g. <code>SMEMBERS</code>.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Why Aedis</h1>
<p >At the time of this writing there are seventeen Redis clients listed in the <a href="https://redis.io/docs/clients/#cpp">official</a> list. With so many clients available it is not unlikely that users are asking themselves why yet another one. In this section I will try to compare Aedis with the most popular clients and why we need Aedis. Notice however that this is ongoing work as comparing client objectively is difficult and time consuming.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Redis-plus-plus</h2>
<p >The most popular client at the moment of this writing ranked by github stars is</p>
<ul>
<li><a href="https://github.com/sewenew/redis-plus-plus">https://github.com/sewenew/redis-plus-plus</a></li>
</ul>
<p >Before we start it is worth mentioning some of the things it does not support</p>
<ul>
<li>RESP3. Without RESP3 is impossible to support some important Redis features like client side caching, among other things.</li>
<li>Coroutines.</li>
<li>Reading responses directly in user data structures avoiding temporaries.</li>
<li>Proper error handling with support for error-code.</li>
<li>Healthy checks.</li>
</ul>
<p >The remaining points will be addressed individually.</p>
<p >Let us first have a look at what sending a command a pipeline and a transaction look like</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> redis = Redis(<span class="stringliteral">&quot;tcp://127.0.0.1:6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send commands</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>); <span class="comment">// val is of type OptionalString.</span></div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending pipelines</span></div>
<div class="line"><span class="keyword">auto</span> pipe = redis.pipeline();</div>
<div class="line"><span class="keyword">auto</span> pipe_replies = pipe.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line">                        .get(<span class="stringliteral">&quot;key&quot;</span>)</div>
<div class="line">                        .rename(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;new-key&quot;</span>)</div>
<div class="line">                        .rpush(<span class="stringliteral">&quot;list&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>})</div>
<div class="line">                        .lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1)</div>
<div class="line">                        .exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse reply with reply type and index.</span></div>
<div class="line"><span class="keyword">auto</span> set_cmd_result = pipe_replies.get&lt;<span class="keywordtype">bool</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending a transaction</span></div>
<div class="line"><span class="keyword">auto</span> tx = redis.transaction();</div>
<div class="line"><span class="keyword">auto</span> tx_replies = tx.incr(<span class="stringliteral">&quot;num0&quot;</span>)</div>
<div class="line">                    .incr(<span class="stringliteral">&quot;num1&quot;</span>)</div>
<div class="line">                    .mget({<span class="stringliteral">&quot;num0&quot;</span>, <span class="stringliteral">&quot;num1&quot;</span>})</div>
<div class="line">                    .exec();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> incr_result0 = tx_replies.get&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p >Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. This makes auto-pipelining impossible.</li>
<li>Any Api that sends individual commands has a very restricted scope of usability and should be avoided for performance reasons.</li>
<li>The API imposes exceptions on users, no error-code overload is provided.</li>
<li>No way to reuse the buffer for new calls to e.g. redis.get in order to avoid further dynamic memory allocations.</li>
<li>Error handling of resolve and connection not clear.</li>
</ul>
<p >According to the documentation, pipelines in redis-plus-plus have the following characteristics</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: By default, creating a Pipeline object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>This is clearly a downside of the API as pipelines should be the default way of communicating and not an exception, paying such a high price for each pipeline imposes a severe cost in performance. Transactions also suffer from the very same problem.</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: Creating a Transaction object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>In Aedis there is no difference between sending one command, a pipeline or a transaction because requests are decoupled from the IO objects.</p>
<blockquote class="doxtable">
<p >&zwj;redis-plus-plus also supports async interface, however, async support for Transaction and Subscriber is still on the way.</p>
<p >The async interface depends on third-party event library, and so far, only libuv is supported. </p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_redis = AsyncRedis(opts, pool_opts);</div>
<div class="line"> </div>
<div class="line">Future&lt;string&gt; ping_res = async_redis.ping();</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; ping_res.get() &lt;&lt; endl;</div>
</div><!-- fragment --><p> As the reader can see, the async interface is based on futures which is also known to have a bad performance. The biggest problem however with this async design is that it makes it impossible to write asynchronous programs correctly since it starts an async operation on every command sent instead of enqueueing a message and triggering a write when it can be sent. It is also not clear how are pipelines realised with the design (if at all).</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Benchmark: Echo server</h2>
<p >This document benchmarks the performance of TCP echo servers I implemented in different languages using different Redis clients. The main motivations for choosing an echo server are</p>
<ul>
<li>Simple to implement and does not require expertise level in most languages.</li>
<li>I/O bound: Echo servers have very low CPU consumption in general and therefore are excelent to measure how a program handles concurrent requests.</li>
<li>It simulates very well a typical backend in regard to concurrency.</li>
</ul>
<p >I also imposed some constraints on the implementations</p>
<ul>
<li>It should be simple enough and not require writing too much code.</li>
<li>Favor the use standard idioms and avoid optimizations that require expert level.</li>
<li>Avoid the use of complex things like connection and thread pool.</li>
</ul>
<p >To reproduce these results run one of the echo-server programs in one terminal and the <a href="https://github.com/mzimbres/aedis/blob/42880e788bec6020dd018194075a211ad9f339e8/benchmarks/cpp/asio/echo_server_client.cpp">echo-server-client</a> in another.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Without Redis</h3>
<p >First I tested a pure TCP echo server, i.e. one that sends the messages directly to the client without interacting with Redis. The result can be seen below</p>
<p ><img src="https://mzimbres.github.io/aedis/tcp-echo-direct.png" alt="" class="inline"/></p>
<p >The tests were performed with a 1000 concurrent TCP connections on the localhost where latency is 0.07ms on average on my machine. On higher latency networks the difference among libraries is expected to decrease.</p>
<ul>
<li>I expected Libuv to have similar performance to Asio and Tokio.</li>
<li>I did expect nodejs to come a little behind given it is is javascript code. Otherwise I did expect it to have similar performance to libuv since it is the framework behind it.</li>
<li>Go did surprise me: faster than nodejs and liuv!</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/cpp/asio/echo_server_direct.cpp">Asio</a>: A variation of <a href="https://github.com/chriskohlhoff/asio/blob/4915cfd8a1653c157a1480162ae5601318553eb8/asio/src/examples/cpp20/coroutines/echo_server.cpp">this</a> Asio example.</li>
<li><a href="https://github.com/mzimbres/aedis/tree/835a1decf477b09317f391eddd0727213cdbe12b/benchmarks/c/libuv">Libuv</a>: Taken from <a href="https://github.com/libuv/libuv/blob/06948c6ee502862524f233af4e2c3e4ca876f5f6/docs/code/tcp-echo-server/main.c">here</a> Libuv example .</li>
<li><a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/rust/echo_server_direct">Tokio</a>: Taken from <a href="https://docs.rs/tokio/latest/tokio/">here</a>.</li>
<li><a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_direct">Nodejs</a></li>
<li><a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_direct.go">Go</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md19"></a>
With Redis</h3>
<p >This is similar to the echo server described above but messages are echoed by Redis and not by the echo-server itself, which acts as a proxy between the client and the Redis server. The results can be seen below</p>
<p ><img src="https://mzimbres.github.io/aedis/tcp-echo-over-redis.png" alt="" class="inline"/></p>
<p >The tests were performed on a network where latency is 35ms on average, otherwise it uses the same number of TCP connections as the previous example.</p>
<p >As the reader can see, the Libuv and the Rust test are not depicted in the graph, the reasons are</p>
<ul>
<li><a href="https://github.com/redis-rs/redis-rs">redis-rs</a>: This client comes so far behind that it can't even be represented together with the other benchmarks without making them look insignificant. I don't know for sure why it is so slow, I suppose it has something to do with its lack of proper <a href="https://redis.io/docs/manual/pipelining/">pipelining</a> support. In fact, the more TCP connections I lauch the worse its performance gets.</li>
<li>Libuv: I left it out because it would require too much work to write it and make it have a good performance. More specifically, I would have to use hiredis and implement support for pipelines manually.</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/mzimbres/aedis">Aedis</a>: <a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/examples/echo_server.cpp">code</a></li>
<li><a href="https://github.com/redis/node-redis">node-redis</a>: <a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_over_redis">code</a></li>
<li><a href="https://github.com/go-redis/redis">go-redis</a>: <a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_over_redis.go">code</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Changelog</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
v1.1.0</h2>
<ul>
<li>Removes <code>coalesce_requests</code> from the <code>aedis::connection::config</code>, it became a request property now, see <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a253cef2ca5d60b1b319019fafb3d27b3" title="Coalesce this with other requests.">aedis::resp3::request::config::coalesce</a></code>.</li>
<li>Removes <code>max_read_size</code> from the <code>aedis::connection::config</code>. The maximum read size can be specified now as a parameter of the <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> function.</li>
<li>Removes <code>aedis::sync</code> class, see <a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a> for how to perform synchronous and thread safe calls. This is possible in Boost. 1.80 only as it requires <code>boost::asio::deferred</code>.</li>
<li>Moves from <code>boost::optional</code> to <code>std::optional</code>. This is part of moving to C++17.</li>
<li>Changes the behaviour of the second <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">aedis::connection::async_run</a></code> overload so that it always returns an error when the connection is lost.</li>
<li>Adds TLS support, see <a class="el" href="intro__tls_8cpp_source.html">intro_tls.cpp</a>.</li>
<li>Adds an example that shows how to resolve addresses over sentinels, see <a class="el" href="subscriber__sentinel_8cpp_source.html">subscriber_sentinel.cpp</a>.</li>
<li>Adds a <code><a class="el" href="classaedis_1_1connection.html#a8ee9dcb7de3732ff3409883cab005382" title="Timeout of the resp3 handshake operation.">aedis::connection::timeouts::resp3_handshake_timeout</a></code>. This is timeout used to send the <code>HELLO</code> command.</li>
<li>Adds <code><a class="el" href="group__high-level-api.html#structaedis_1_1endpoint" title="A Redis endpoint.">aedis::endpoint</a></code> where in addition to host and port, users can optionally provide username, password and the expected server role (see <code><a class="el" href="group__high-level-api.html#gga1833aa5e140bbaa9d319ecb1a71bd8baa72a58510e4bd5f265721fcb3e22336e2" title="Unexpected server role.">aedis::error::unexpected_server_role</a></code>).</li>
<li><code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">aedis::connection::async_run</a></code> checks whether the server role received in the hello command is equal to the expected server role specified in <code><a class="el" href="group__high-level-api.html#structaedis_1_1endpoint" title="A Redis endpoint.">aedis::endpoint</a></code>. To skip this check let the role variable empty.</li>
<li>Removes reconnect functionality from <code><a class="el" href="classaedis_1_1connection.html" title="A connection to the Redis server.">aedis::connection</a></code>. It is possible in simple reconnection strategies but bloats the class in more complex scenarios, for example, with sentinel, authentication and TLS. This is trivial to implement in a separate coroutine. As a result the enum <code>event</code> and <code>async_receive_event</code> have been removed from the class too.</li>
<li>Fixes a bug in <code><a class="el" href="classaedis_1_1connection.html#a64109cde6ce5eb31aa36ff85cc43ce95" title="Receives server side pushes asynchronously.">connection::async_receive_push</a></code> that prevented passing any response adapter other that <code>adapt(std::vector&lt;node&gt;)</code>.</li>
<li>Changes the behaviour of <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> that caused RESP3 errors to be ignored. One consequence of it is that <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">connection::async_run</a></code> would not exit with failure in servers that required authentication.</li>
<li>Changes the behaviour of <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">connection::async_run</a></code> that would cause it to complete with success when an error in the <code><a class="el" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> occurred.</li>
<li>Ports the buildsystem from autotools to CMake.</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
v1.0.0</h2>
<ul>
<li>Adds experimental cmake support for windows users.</li>
<li>Adds new class <code>aedis::sync</code> that wraps an <code><a class="el" href="classaedis_1_1connection.html" title="A connection to the Redis server.">aedis::connection</a></code> in a thread-safe and synchronous API. All free functions from the <code>sync.hpp</code> are now member functions of <code>aedis::sync</code>.</li>
<li>Split <code>aedis::connection::async_receive_event</code> in two functions, one to receive events and another for server side pushes, see <code><a class="el" href="classaedis_1_1connection.html#a64109cde6ce5eb31aa36ff85cc43ce95" title="Receives server side pushes asynchronously.">aedis::connection::async_receive_push</a></code>.</li>
<li>Removes collision between <code>aedis::adapter::adapt</code> and <code>aedis::adapt</code>.</li>
<li>Adds <code>connection::operation</code> enum to replace <code>cancel_*</code> member functions with a single cancel function that gets the operations that should be cancelled as argument.</li>
<li>Bugfix: a bug on reconnect from a state where the <code>connection</code> object had unsent commands. It could cause <code>async_exec</code> to never complete under certain conditions.</li>
<li>Bugfix: Documentation of <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">adapt()</a></code> functions were missing from Doxygen.</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
v0.3.0</h2>
<ul>
<li>Adds <code>experimental::exec</code> and <code>receive_event</code> functions to offer a thread safe and synchronous way of executing requests across threads. See <code><a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a></code> and <code>subscriber_sync.cpp</code> for examples.</li>
<li><code>connection::async_read_push</code> was renamed to <code>async_receive_event</code>.</li>
<li><code>connection::async_receive_event</code> is now being used to communicate internal events to the user, such as resolve, connect, push etc. For examples see <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a> and <code>connection::event</code>.</li>
<li>The <code>aedis</code> directory has been moved to <code>include</code> to look more similar to Boost libraries. Users should now replace <code>-I/aedis-path</code> with <code>-I/aedis-path/include</code> in the compiler flags.</li>
<li>The <code>AUTH</code> and <code>HELLO</code> commands are now sent automatically. This change was necessary to implement reconnection. The username and password used in <code>AUTH</code> should be provided by the user on <code>connection::config</code>.</li>
<li>Adds support for reconnection. See <code>connection::enable_reconnect</code>.</li>
<li>Fixes a bug in the <code>connection::async_run(host, port)</code> overload that was causing crashes on reconnection.</li>
<li>Fixes the executor usage in the connection class. Before theses changes it was imposing <code>any_io_executor</code> on users.</li>
<li><code>connection::async_receiver_event</code> is not cancelled anymore when <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">connection::async_run</a></code> exits. This change makes user code simpler.</li>
<li><code><a class="el" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> with host and port overload has been removed. Use the other <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">connection::async_run</a></code> overload.</li>
<li>The host and port parameters from <code><a class="el" href="classaedis_1_1connection.html#ab13b8c7ea4e3c41faec732e048188558" title="Starts communication with the Redis server asynchronously.">connection::async_run</a></code> have been move to <code>connection::config</code> to better support authentication and failover.</li>
<li>Many simplifications in the <code>chat_room</code> example.</li>
<li>Fixes build in clang the compilers and makes some improvements in the documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
v0.2.1</h2>
<ul>
<li>Fixes a bug that happens on very high load.</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
v0.2.0</h2>
<ul>
<li>Major rewrite of the high-level API. There is no more need to use the low-level API anymore.</li>
<li>No more callbacks: Sending requests follows the ASIO asynchronous model.</li>
<li>Support for reconnection: Pending requests are not canceled when a connection is lost and are re-sent when a new one is established.</li>
<li>The library is not sending HELLO-3 on user behalf anymore. This is important to support AUTH properly.</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
v0.1.2</h2>
<ul>
<li>Adds reconnect coroutine in the <code>echo_server</code> example.</li>
<li>Corrects <code>client::async_wait_for_data</code> with <code>make_parallel_group</code> to launch operation.</li>
<li>Improvements in the documentation.</li>
<li>Avoids dynamic memory allocation in the client class after reconnection.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
v0.1.1</h2>
<ul>
<li>Improves the documentation and adds some features to the high-level client.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
v0.1.0</h2>
<ul>
<li>Improvements in the design and documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
v0.0.1</h2>
<ul>
<li>First release to collect design feedback.</li>
</ul>
<h1><a class="anchor" id="autotoc_md30"></a>
Acknowledgement</h1>
<p >Acknowledgement to people that helped shape Aedis in one way or another.</p>
<ul>
<li>Richard Hodges (<a href="https://github.com/madmongo1">madmongo1</a>): For very helpful support with Asio, the design of asynchronous programs, etc.</li>
<li>Vinícius dos Santos Oliveira (<a href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful discussion about how Aedis consumes buffers in the read operation.</li>
<li>Petr Dannhofer (<a href="https://github.com/Eddie-cz">Eddie-cz</a>): For helping me understand how the <code>AUTH</code> and <code>HELLO</code> command can influence each other.</li>
<li>Mohammad Nejati (<a href="https://github.com/ashtum">ashtum</a>): For pointing scenarios where calls to <code>async_exec</code> should fail when the connection is lost.</li>
<li>Klemens Morgenstern (<a href="https://github.com/klemens-morgenstern">klemens-morgenstern</a>): For useful discussion about timeouts, the synchronous interface and general help with Asio. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
Author: Marcelo Zimbres Silva.
</address>
</body>
</html>
