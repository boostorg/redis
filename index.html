<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aedis: Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aedis.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="6">
 <tbody>
 <tr>
  <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">Aedis 1.3.1</font> &#160; <br> A redis client designed for performance and scalability </td>
  <td style="width:100%">         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1">Overview</a><ul><li class="level2"><a href="#autotoc_md2">Requests</a><ul><li class="level3"><a href="#autotoc_md3">Serialization</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md4">Responses</a><ul><li class="level3"><a href="#autotoc_md5">Pushes</a></li>
<li class="level3"><a href="#autotoc_md6">Null</a></li>
<li class="level3"><a href="#autotoc_md7">Transactions</a></li>
<li class="level3"><a href="#autotoc_md8">Deserialization</a></li>
<li class="level3"><a href="#autotoc_md9">The general case</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md10">Connection</a><ul><li class="level3"><a href="#autotoc_md11">Run</a></li>
<li class="level3"><a href="#autotoc_md12">Execute</a></li>
<li class="level3"><a href="#autotoc_md13">Receive</a></li>
<li class="level3"><a href="#autotoc_md14">Cancellation</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md15">Why Aedis</a><ul><li class="level2"><a href="#autotoc_md16">Echo server benchmark</a><ul><li class="level3"><a href="#autotoc_md17">Without Redis</a></li>
<li class="level3"><a href="#autotoc_md18">With Redis</a></li>
<li class="level3"><a href="#autotoc_md19">Conclusion</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md20">Reference</a></li>
<li class="level1"><a href="#autotoc_md21">Installation</a></li>
<li class="level1"><a href="#autotoc_md22">Acknowledgement</a></li>
<li class="level1"><a href="#autotoc_md23">Changelog</a><ul><li class="level2"><a href="#autotoc_md24">v1.3.0-1</a></li>
<li class="level2"><a href="#autotoc_md25">v1.2.0</a></li>
<li class="level2"><a href="#autotoc_md26">v1.1.0-1</a></li>
<li class="level2"><a href="#autotoc_md27">v1.0.0</a></li>
<li class="level2"><a href="#autotoc_md28">v0.3.0</a></li>
<li class="level2"><a href="#autotoc_md29">v0.2.0-1</a></li>
<li class="level2"><a href="#autotoc_md30">v0.1.0-2</a></li>
<li class="level2"><a href="#autotoc_md31">v0.0.1</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p >Aedis is a high-level <a href="https://redis.io/">Redis</a> client library built on top of <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Asio</a>. Some of its distinctive features are</p>
<ul>
<li>Support for the latest version of the Redis communication protocol <a href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>.</li>
<li>Support for STL containers, TLS and Redis sentinel.</li>
<li>Serialization and deserialization of your own data types.</li>
<li>Back pressure, cancellation and low latency.</li>
</ul>
<p >In addition to that, Aedis hides most of the low-level Asio code away from the user, which in the majority of the cases will be concerned with three library entities</p>
<ul>
<li><code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code>: A container of Redis commands.</li>
<li><code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code>: A function that adapts data structures to receive Redis responses.</li>
<li><code>aedis::connection</code>: A connection to the Redis server.</li>
</ul>
<p >For example, the coroutine below reads Redis <a href="https://redis.io/docs/data-types/hashes/">hashes</a> in a <code>std::map</code> and quits the connection (see <a class="el" href="containers_8cpp_source.html">containers.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> hgetall(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// A request contains multiple Redis commands.</span></div>
<div class="line">   request req;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">   req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;hset-key&quot;</span>);</div>
<div class="line">   req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Tuple elements will hold the response to each command in the request.</span></div>
<div class="line">   std::tuple&lt;aedis::ignore, std::map&lt;std::string, std::string&gt;, <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>&gt; resp;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Executes the request and reads the response.</span></div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Uses the map ...</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__high-level-api_html_ga0d619e51ab37f7854e7218a061900820"><div class="ttname"><a href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a></div><div class="ttdeci">adapter::detail::ignore ignore</div><div class="ttdoc">Tag used to ignore responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00036">adapt.hpp:36</a></div></div>
<div class="ttc" id="agroup__high-level-api_html_gac56bb1a8df93445853a4b9dae2d97b6e"><div class="ttname"><a href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">aedis::adapt</a></div><div class="ttdeci">auto adapt(std::size_t max_read_size=(std::numeric_limits&lt; std::size_t &gt;::max)()) noexcept</div><div class="ttdoc">Creates an adapter that ignores responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00199">adapt.hpp:199</a></div></div>
</div><!-- fragment --><p >The execution of <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> as shown above must still be triggered by the <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> member function. For example, the code below uses a short-lived connection to execute the coroutine above</p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; async_main()</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">auto</span> conn = std::make_shared&lt;connection&gt;(<span class="keyword">co_await</span> net::this_coro::executor);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Resolves and connects (from examples/common.hpp to avoid vebosity)</span></div>
<div class="line">   <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Runs hgetall (previous example).</span></div>
<div class="line">   <span class="keyword">co_await</span> (conn-&gt;async_run() || hgetall(conn));</div>
<div class="line">}</div>
</div><!-- fragment --><p >Long-lived connections follow the same principle (see the examples below) and will be discussed in more detail later. The role of the <code>async_run</code> is to coordinate IO and ensure the connection is always reading from the socket. The reationale behind this design is</p>
<ul>
<li>Provide quick reaction to disconnections and hence faster failovers.</li>
<li>Support server pushes and requests in the same connection object, concurrently.</li>
</ul>
<p >Before we see with more detail how connections, requests and responses work, users might find it useful to skim over the examples in order to gain a better feeling about the library capabilities.</p>
<ul>
<li><a class="el" href="intro_8cpp_source.html">intro.cpp</a>: The Aedis hello-world program. Sends one command and quits the connection.</li>
<li><a class="el" href="intro__tls_8cpp_source.html">intro_tls.cpp</a>: Same as <a class="el" href="intro_8cpp_source.html">intro.cpp</a> but over TLS.</li>
<li><a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a>: Shows how to use the conneciton class synchronously.</li>
<li><a class="el" href="containers_8cpp_source.html">containers.cpp</a>: Shows how to send and receive STL containers and how to use transactions.</li>
<li><a class="el" href="serialization_8cpp_source.html">serialization.cpp</a>: Shows how to serialize types using Boost.Json.</li>
<li><a class="el" href="resolve__with__sentinel_8cpp_source.html">resolve_with_sentinel.cpp</a>: Shows how to resolve a master address using sentinels.</li>
<li><a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>: Shows how to implement pubsub with reconnection re-subscription.</li>
<li><a class="el" href="echo__server_8cpp_source.html">echo_server.cpp</a>: A simple TCP echo server.</li>
<li><a class="el" href="chat__room_8cpp_source.html">chat_room.cpp</a>: A command line chat built on Redis pubsub.</li>
<li><a class="el" href="low__level__sync_8cpp_source.html">low_level_sync.cpp</a>: Sends a ping synchronously using the low-level API.</li>
<li><a class="el" href="low__level__async_8cpp_source.html">low_level_async.cpp</a>: Sends a ping asynchronously using the low-level API.</li>
</ul>
<p >To avoid repetition code that is common to all examples have been grouped in <a class="el" href="common_8hpp_source.html">common.hpp</a>. The main function used in some async examples has been factored out in the <a class="el" href="main_8cpp_source.html">main.cpp</a> file.</p>
<p ><a class="anchor" id="requests"></a> </p>
<h2><a class="anchor" id="autotoc_md2"></a>
Requests</h2>
<p >Redis requests are composed of one or more Redis commands (in Redis documentation they are called <a href="https://redis.io/topics/pipelining">pipelines</a>). For example</p>
<div class="fragment"><div class="line"><span class="comment">// Some example containers.</span></div>
<div class="line">std::list&lt;std::string&gt; list {...};</div>
<div class="line">std::map&lt;std::string, mystruct&gt; map { ...};</div>
<div class="line"> </div>
<div class="line">request req;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with variable length of arguments.</span></div>
<div class="line">req.push(<span class="stringliteral">&quot;SET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;some value&quot;</span>, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a list.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but as an iterator range.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, std::cbegin(list), std::cend(list));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a map.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Sending a request to Redis is performed with <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">aedis::connection::async_exec</a></code> as already stated.</p>
<p ><a class="anchor" id="serialization"></a></p>
<h3><a class="anchor" id="autotoc_md3"></a>
Serialization</h3>
<p >The <code><a class="el" href="classaedis_1_1resp3_1_1request.html#ae9cfe90ea55427d5345846f80b70be1b" title="Appends a new command to the end of the request.">resp3::request::push</a></code> and <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a3c4321c7c14eb92a977c48b0433c424e" title="Appends a new command to the end of the request.">resp3::request::push_range</a></code> member functions work with integer data types e.g. <code>int</code> and <code>std::string</code> out of the box. To send your own data type define a <code>to_bulk</code> function like this</p>
<div class="fragment"><div class="line"><span class="comment">// Example struct.</span></div>
<div class="line"><span class="keyword">struct </span>mystruct {...};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Serialize your data structure here.</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a30ed6048af1b522f52d7e0e53eac4332">to_bulk</a>(std::pmr::string&amp; to, mystruct <span class="keyword">const</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">   std::string dummy = <span class="stringliteral">&quot;Dummy serializaiton string.&quot;</span>;</div>
<div class="line">   aedis::resp3::to_bulk(to, dummy);</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1resp3_1_1request_html_a30ed6048af1b522f52d7e0e53eac4332"><div class="ttname"><a href="classaedis_1_1resp3_1_1request.html#a30ed6048af1b522f52d7e0e53eac4332">aedis::resp3::request::to_bulk</a></div><div class="ttdeci">void to_bulk(Request &amp;to, boost::string_view data)</div><div class="ttdoc">Adds a bulk to the request.</div><div class="ttdef"><b>Definition:</b> <a href="request_8hpp_source.html#l00049">request.hpp:49</a></div></div>
</div><!-- fragment --><p >Once <code>to_bulk</code> is defined and visible over ADL <code>mystruct</code> can be passed to the <code>request</code></p>
<div class="fragment"><div class="line">request req;</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, mystruct&gt; map {...};</div>
<div class="line"> </div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Example <a class="el" href="serialization_8cpp_source.html">serialization.cpp</a> shows how store json string in Redis.</p>
<p ><a class="anchor" id="responses"></a></p>
<h2><a class="anchor" id="autotoc_md4"></a>
Responses</h2>
<p >Aedis uses the following strategy to support Redis responses</p>
<ul>
<li><b>Static</b>: For <code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code> whose sizes are known at compile time std::tuple is supported.</li>
<li><b>Dynamic</b>: Otherwise use <code>std::vector&lt;<a class="el" href="structaedis_1_1resp3_1_1node.html" title="A node in the response tree.">aedis::resp3::node</a>&lt;std::string&gt;&gt;</code>.</li>
</ul>
<p >For example, below is a request with a compile time size</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;INCR&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >To read the response to this request users can use the following tuple</p>
<div class="fragment"><div class="line">std::tuple&lt;std::string, int, std::string&gt;</div>
</div><!-- fragment --><p >The pattern might have become apparent to the reader: the tuple must have as many elements as the request has commands (exceptions below). It is also necessary that each tuple element is capable of storing the response to the command it refers to, otherwise an error will ocurr. To ignore responses to individual commands in the request use the tag <code>aedis::ignore</code></p>
<div class="fragment"><div class="line"><span class="comment">// Ignore the second and last responses.</span></div>
<div class="line">std::tuple&lt;std::string, aedis::ignore, std::string, aedis::ignore&gt;</div>
</div><!-- fragment --><p >The following table provides the resp3-types returned by some Redis commands</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lpush   </td><td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lrange   </td><td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set   </td><td class="markdownTableBodyNone">Simple-string, null or blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/set">https://redis.io/commands/set</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">get   </td><td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/get">https://redis.io/commands/get</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">smembers   </td><td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hgetall   </td><td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a>   </td></tr>
</table>
<p >To map these RESP3 types into a C++ data structure use the table below</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Possible C++ type   </th><th class="markdownTableHeadNone">Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple-string   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple-error   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blob-error   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><code>long long</code>, <code>int</code>, <code>std::size_t</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone"><code>double</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Null   </td><td class="markdownTableBodyNone"><code>std::optional&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::list</code>, <code>std::array</code>, <code>std::deque</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::set</code>, <code>std::unordered_set</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Push   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate   </td></tr>
</table>
<p >For example, the response to the request</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;RPUSH&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>, vec);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, map);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key4&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >can be read in the tuple below</p>
<div class="fragment"><div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// hello</span></div>
<div class="line">   int,            <span class="comment">// rpush</span></div>
<div class="line">   int,            <span class="comment">// hset</span></div>
<div class="line">   std::vector&lt;T&gt;, <span class="comment">// lrange</span></div>
<div class="line">   std::map&lt;U, V&gt;, <span class="comment">// hgetall</span></div>
<div class="line">   std::string     <span class="comment">// quit</span></div>
<div class="line">&gt; resp;</div>
</div><!-- fragment --><p >Where both are passed to <code>async_exec</code> as showed elsewhere</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >If the intention is to ignore the response to all commands altogether use <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">adapt()</a></code> without arguments instead</p>
<div class="fragment"><div class="line"><span class="comment">// Uses the ignore adapter explicitly.</span></div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Ignore adapter is also the default argument.</span></div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req);</div>
</div><!-- fragment --><p >Responses that contain nested aggregates or heterogeneous data types will be given special treatment later in <a class="el" href="index.html#the-general-case">The general case</a>. As of this writing, not all RESP3 types are used by the Redis server, which means in practice users will be concerned with a reduced subset of the RESP3 specification.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Pushes</h3>
<p >Commands that have push response like</p>
<ul>
<li><code>"SUBSCRIBE"</code></li>
<li><code>"PSUBSCRIBE"</code></li>
<li><code>"UNSUBSCRIBE"</code></li>
</ul>
<p >must be <b>NOT</b> be included in the tuple. For example, the request below</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, <span class="stringliteral">&quot;channel&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >must be read in this tuple <code>std::tuple&lt;std::string, std::string&gt;</code>, that has size two.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Null</h3>
<p >It is not uncommon for apps to access keys that do not exist or that have already expired in the Redis server, to deal with these cases Aedis provides support for <code>std::optional</code>. To use it, wrap your type around <code>std::optional</code> like this</p>
<div class="fragment"><div class="line">std::tuple&lt;</div>
<div class="line">   std::optional&lt;A&gt;,</div>
<div class="line">   std::optional&lt;B&gt;,</div>
<div class="line">   ...</div>
<div class="line">   &gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >Everything else stays pretty much the same.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Transactions</h3>
<p >To read responses to transactions we must first observe that Redis will queue the transaction commands and send their individual responses as elements of an array, the array is itself the response to the <code>EXEC</code> command. For example, to read the response to this request</p>
<div class="fragment"><div class="line">req.push(<span class="stringliteral">&quot;MULTI&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;EXEC&quot;</span>);</div>
</div><!-- fragment --><p >use the following response type</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>exec_resp_type = </div>
<div class="line">   std::tuple&lt;</div>
<div class="line">      std::optional&lt;std::string&gt;, <span class="comment">// get</span></div>
<div class="line">      std::optional&lt;std::vector&lt;std::string&gt;&gt;, <span class="comment">// lrange</span></div>
<div class="line">      std::optional&lt;std::map&lt;std::string, std::string&gt;&gt; <span class="comment">// hgetall</span></div>
<div class="line">   &gt;;</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// multi</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// get</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// lrange</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// hgetall</span></div>
<div class="line">   exec_resp_type, <span class="comment">// exec</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >For a complete example see <a class="el" href="containers_8cpp_source.html">containers.cpp</a>.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Deserialization</h3>
<p >As mentioned in <a class="el" href="index.html#serialization">serialization</a>, it is common practice to serialize data before sending it to Redis e.g. as json strings. For performance and convenience reasons, we may also want to deserialize responses directly in their final data structure. Aedis supports this use case by calling a user provided <code>from_bulk</code> function while parsing the response. For example</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> from_bulk(mystruct&amp; obj, <span class="keywordtype">char</span> <span class="keyword">const</span>* p, std::size_t size, boost::system::error_code&amp; ec)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Deserializes p into obj.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >After that, you can start receiving data efficiently in the desired types e.g. <code>mystruct</code>, <code>std::map&lt;std::string, mystruct&gt;</code> etc.</p>
<p ><a class="anchor" id="the-general-case"></a></p>
<h3><a class="anchor" id="autotoc_md9"></a>
The general case</h3>
<p >There are cases where responses to Redis commands won't fit in the model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose responses don't have a fixed RESP3 type. Expecting an <code>int</code> and receiving a blob-string will result in error.</li>
<li>RESP3 aggregates that contain nested aggregates can't be read in STL containers.</li>
<li>Transactions with a dynamic number of commands can't be read in a <code>std::tuple</code>.</li>
</ul>
<p >To deal with these cases Aedis provides the <code><a class="el" href="structaedis_1_1resp3_1_1node.html" title="A node in the response tree.">aedis::resp3::node</a></code> type abstraction, that is the most general form of an element in a response, be it a simple RESP3 type or the element of an aggregate. It is defined like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;</div>
<div class="line"><span class="keyword">struct </span>node {</div>
<div class="line">   <span class="comment">// The RESP3 type of the data in this node.</span></div>
<div class="line">   <a class="code hl_enumeration" href="group__high-level-api.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">type</a> data_type;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The number of elements of an aggregate (or 1 for simple data).</span></div>
<div class="line">   std::size_t aggregate_size;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The depth of this node in the response tree.</span></div>
<div class="line">   std::size_t depth;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The actual data. For aggregate types this is always empty.</span></div>
<div class="line">   String value;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__high-level-api_html_gabdb6bdf6f96b4a7a91ed63d2324cef57"><div class="ttname"><a href="group__high-level-api.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">aedis::resp3::type</a></div><div class="ttdeci">type</div><div class="ttdoc">RESP3 data types.</div><div class="ttdef"><b>Definition:</b> <a href="type_8hpp_source.html#l00021">type.hpp:22</a></div></div>
</div><!-- fragment --><p >Any response to a Redis command can be received in a <code>std::vector&lt;node&lt;std::string&gt;&gt;</code>. The vector can be seen as a pre-order view of the response tree. Using it is not different than using other types</p>
<div class="fragment"><div class="line"><span class="comment">// Receives any RESP3 simple or aggregate data type.</span></div>
<div class="line">std::vector&lt;node&lt;std::string&gt;&gt; resp;</div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >For example, suppose we want to retrieve a hash data structure from Redis with <code>HGETALL</code>, some of the options are</p>
<ul>
<li><code>std::vector&lt;node&lt;std::string&gt;</code>: Works always.</li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all elements as string.</li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if you need the data as a <code>std::map</code>.</li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing serialized data. Avoids temporaries and requires <code>from_bulk</code> for <code>U</code> and <code>V</code>.</li>
</ul>
<p >In addition to the above users can also use unordered versions of the containers. The same reasoning also applies to sets e.g. <code>SMEMBERS</code> and other data structures in general.</p>
<p ><a class="anchor" id="connection"></a> </p>
<h2><a class="anchor" id="autotoc_md10"></a>
Connection</h2>
<p >The <code>aedis::connection</code> is a class that provides async-only communication with a Redis server by means of three member functions</p>
<ul>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code>: Starts read and write operations and remains suspended until the connection is lost.</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code>: Executes commands.</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#ac865f2f3339856b4bbe233e353a3a6b3" title="Receives server side pushes asynchronously.">connection::async_receive</a></code>: Receives server-side pushes.</li>
</ul>
<p >In general, these operations will be running concurrently in user application, where, for example</p>
<ol type="1">
<li><b>Run</b>: One coroutine will call <code>async_run</code>, perhaps with other operations like healthy checks and in a loop to implement reconnection.</li>
<li><b>Execute</b>: Multiple coroutines will call <code>async_exec</code> independently and without coordination (e.g. queuing).</li>
<li><b>Receive</b>: One coroutine will loop on <code>async_receive</code> to receive server-side pushes (required only if the app expects server pushes).</li>
</ol>
<p >Each of these operations can be performed without regards to the others as they are independent from each other. Below we will cover the points above with more detail.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Run</h3>
<p >The code snipet in the overview section has shown us an example that used <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> in short-lived connection, in the general case however, applications will connect to a Redis server and hang around for as long as possible, until the connection is lost for some reason. When that happens, simple setups will want to wait for a short period of time and try to reconnect. To support this usage pattern Aedis connections can be reconnected <em>while there are pending requests and receive operations</em>. The general form of a reconnect loop looks like this (see <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_main() -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">auto</span> ex = <span class="keyword">co_await</span> net::this_coro::executor;</div>
<div class="line">   <span class="keyword">auto</span> conn = std::make_shared&lt;connection&gt;(ex);</div>
<div class="line">   signal_set_type sig{ex, SIGINT, SIGTERM};</div>
<div class="line">   timer_type timer{ex};</div>
<div class="line"> </div>
<div class="line">   request req;</div>
<div class="line">   req.get_config().cancel_on_connection_lost = <span class="keyword">true</span>;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">   req.push(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, <span class="stringliteral">&quot;channel&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Loop to reconnect on connection lost. To exit type Ctrl-C twice.</span></div>
<div class="line">   <span class="keywordflow">for</span> (;;) {</div>
<div class="line">      <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Starts async_run and other operations.</span></div>
<div class="line">      <span class="keyword">co_await</span> ((conn-&gt;async_run() || healthy_checker(conn) || sig.async_wait() ||</div>
<div class="line">               receiver(conn)) &amp;&amp; conn-&gt;async_exec(req));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Prepare for a reconnect.</span></div>
<div class="line">      conn-&gt;reset_stream();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Waits some time before reconnecting.</span></div>
<div class="line">      timer.expires_after(std::chrono::seconds{1});</div>
<div class="line">      <span class="keyword">co_await</span> timer.async_wait();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p >It is important to emphasize that Redis servers use the old communication protocol RESP2 by default, therefore it is necessary to send a <code>HELLO 3</code> command everytime a connection is established. Another common scenario for reconnection is, for example, a failover with sentinels, covered in <code><a class="el" href="resolve__with__sentinel_8cpp_source.html">resolve_with_sentinel.cpp</a></code> example.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Execute</h3>
<p >The basic idea about <code>async_exec</code> was stated above already: execute Redis commands. One of the most important things about it however is that it can be called multiple times without coordination, for example, in a HTTP or Websocket server where each session calls it independently to communicate with Redis. The benefits of this feature are manifold</p>
<ul>
<li>Reduces code complexity as users won't have to implement queues every time e.g. different HTTP sessions want to share a connection to Redis.</li>
<li>A small number of connections improves the performance associated with <a href="https://redis.io/topics/pipelining">pipelines</a>. A single connection will be indeed enough in most of cases.</li>
</ul>
<p >There are some important things about <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> that are worth stating here</p>
<ul>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> will write a request and read the response directly in the data structure passed by the user, avoiding temporaries altogether.</li>
<li>Requests belonging to different <code>async_exec</code> will be coalesced in a single payload (pipelined) and written only once, improving performance massively.</li>
<li>Users have full control whether <code>async_exec</code> should remain suspended if a connection is lost, (among other things). See <code><a class="el" href="classaedis_1_1resp3_1_1request.html#structaedis_1_1resp3_1_1request_1_1config" title="Request configuration options.">aedis::resp3::request::config</a></code>.</li>
</ul>
<p >The code below illustrates this concepts in a TCP session of the <code><a class="el" href="echo__server_8cpp_source.html">echo_server.cpp</a></code> example</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> echo_server_session(tcp_socket socket, std::shared_ptr&lt;connection&gt; db) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   request req;</div>
<div class="line">   std::tuple&lt;std::string&gt; response;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (std::string buffer;;) {</div>
<div class="line">      <span class="comment">// Reads a user message.</span></div>
<div class="line">      <span class="keyword">auto</span> n = <span class="keyword">co_await</span> net::async_read_until(socket, net::dynamic_buffer(buffer, 1024), <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Echos it through Redis.</span></div>
<div class="line">      req.push(<span class="stringliteral">&quot;PING&quot;</span>, buffer);</div>
<div class="line">      <span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(response));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Writes is back to the user.</span></div>
<div class="line">      <span class="keyword">co_await</span> <a class="code hl_function" href="group__low-level-api.html#ga54dda2974f233dd25a2eaf20ce9b5385">net::async_write</a>(socket, net::buffer(std::get&lt;0&gt;(response)));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Cleanup</span></div>
<div class="line">      std::get&lt;0&gt;(response).clear();</div>
<div class="line">      req.clear();</div>
<div class="line">      buffer.erase(0, n);</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__low-level-api_html_ga54dda2974f233dd25a2eaf20ce9b5385"><div class="ttname"><a href="group__low-level-api.html#ga54dda2974f233dd25a2eaf20ce9b5385">aedis::resp3::async_write</a></div><div class="ttdeci">auto async_write(AsyncWriteStream &amp;stream, Request const &amp;req, CompletionToken &amp;&amp;token=boost::asio::default_completion_token_t&lt; typename AsyncWriteStream::executor_type &gt;{})</div><div class="ttdoc">Writes a request asynchronously.</div><div class="ttdef"><b>Definition:</b> <a href="write_8hpp_source.html#l00053">write.hpp:53</a></div></div>
</div><!-- fragment --><p >Notice also how the session above provides back-pressure as the coroutine won't read the next message from the socket until a cycle is complete.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Receive</h3>
<p >Receiving Redis pushes works similar to the <code>async_exec</code> discussed above but without the request. The example below was taken from <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a></p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; push_receiver(std::shared_ptr&lt;connection&gt; conn)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">for</span> (std::vector&lt;node&lt;std::string&gt;&gt; resp;;) {</div>
<div class="line">      <span class="keyword">co_await</span> conn-&gt;async_receive(<a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line">      print_push(resp);</div>
<div class="line">      resp.clear();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p >In general, it is advisable to all apps to keep a coroutine calling <code>async_receive</code> as an unread push will cause the connection to stall and eventually timeout. Notice that the same connection that is being used to send requests can be also used to receive server-side pushes.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Cancellation</h3>
<p >Aedis supports both implicit and explicit cancellation of connection operations. Explicit cancellation is supported by means of the <code><a class="el" href="classaedis_1_1basic__connection.html#a6031e4ec3662db74a0ce94e0877bae12" title="Cancel operations.">aedis::connection::cancel</a></code> member function. Implicit cancellation, like those that may happen when using Asio awaitable operators &amp;&amp; and || will be discussed with more detail below.</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_run(...) &amp;&amp; conn.async_exec(...))</div>
</div><!-- fragment --><ul>
<li>Useful when implementing reconnection.</li>
<li><code>async_exec</code> is responsible for sending the <code>HELLO</code> command and optionally for subscribing to channels.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_run(...) || conn.async_exec(...))</div>
</div><!-- fragment --><ul>
<li>Useful for short-lived connections that are meant to be closed after a command has been executed.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_exec(...) || time.async_wait(...))</div>
</div><!-- fragment --><ul>
<li>Provides a way to limit how long the execution of a single request should last.</li>
<li>The cancellation will be ignored if the request has already been written to the socket.</li>
<li>It is usually a better idea to have a healthy checker than adding per request timeout, see <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a> for an example.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_run(...) || time.async_wait(...))</div>
</div><!-- fragment --><ul>
<li>Sets a limit on how long the connection should live.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_exec(...) || conn.async_exec(...) || ... || conn.async_exec(...))</div>
</div><!-- fragment --><ul>
<li>This works but is considered an antipattern. Unless the user has set <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a253cef2ca5d60b1b319019fafb3d27b3" title="If true the request will be coalesced with other requests, see https://redis.io/topics/pipelining....">aedis::resp3::request::config::coalesce</a></code> to <code>false</code>, and he shouldn't, the connection will automatically merge the individual requests into a single payload anyway.</li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
Why Aedis</h1>
<p >The main reason for why I started writing Aedis was to have a client compatible with the Asio asynchronous model. As I made progresses I could also address what I considered weaknesses in other libraries. Due to time constraints I won't be able to give a detailed comparison with each client listed in the <a href="https://redis.io/docs/clients/#cpp">official</a> list, instead I will focus on the most popular C++ client on github in number of stars, namely</p>
<ul>
<li><a href="https://github.com/sewenew/redis-plus-plus">https://github.com/sewenew/redis-plus-plus</a></li>
</ul>
<p >Before we start it is important to mentioning some of the things redis-plus-plus does not support</p>
<ul>
<li>The latest version of the communication protocol RESP3. Without it it is impossible to support some important Redis features like client side caching, among other things.</li>
<li>Coroutines.</li>
<li>Reading responses directly in user data structures to avoid creating temporaries.</li>
<li>Error handling with support for error-code.</li>
<li>Cancellation.</li>
</ul>
<p >The remaining points will be addressed individually. Let us first have a look at what sending a command a pipeline and a transaction look like</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> redis = Redis(<span class="stringliteral">&quot;tcp://127.0.0.1:6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send commands</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>); <span class="comment">// val is of type OptionalString.</span></div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending pipelines</span></div>
<div class="line"><span class="keyword">auto</span> pipe = redis.pipeline();</div>
<div class="line"><span class="keyword">auto</span> pipe_replies = pipe.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line">                        .get(<span class="stringliteral">&quot;key&quot;</span>)</div>
<div class="line">                        .rename(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;new-key&quot;</span>)</div>
<div class="line">                        .rpush(<span class="stringliteral">&quot;list&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>})</div>
<div class="line">                        .lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1)</div>
<div class="line">                        .exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse reply with reply type and index.</span></div>
<div class="line"><span class="keyword">auto</span> set_cmd_result = pipe_replies.get&lt;<span class="keywordtype">bool</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending a transaction</span></div>
<div class="line"><span class="keyword">auto</span> tx = redis.transaction();</div>
<div class="line"><span class="keyword">auto</span> tx_replies = tx.incr(<span class="stringliteral">&quot;num0&quot;</span>)</div>
<div class="line">                    .incr(<span class="stringliteral">&quot;num1&quot;</span>)</div>
<div class="line">                    .mget({<span class="stringliteral">&quot;num0&quot;</span>, <span class="stringliteral">&quot;num1&quot;</span>})</div>
<div class="line">                    .exec();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> incr_result0 = tx_replies.get&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p >Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. This makes auto-pipelining impossible.</li>
<li>Any Api that sends individual commands has a very restricted scope of usability and should be avoided for performance reasons.</li>
<li>The API imposes exceptions on users, no error-code overload is provided.</li>
<li>No way to reuse the buffer for new calls to e.g. redis.get in order to avoid further dynamic memory allocations.</li>
<li>Error handling of resolve and connection not clear.</li>
</ul>
<p >According to the documentation, pipelines in redis-plus-plus have the following characteristics</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: By default, creating a Pipeline object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>This is clearly a downside in the API as pipelines should be the default way of communicating and not an exception, paying such a high price for each pipeline imposes a severe cost in performance. Transactions also suffer from the very same problem.</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: Creating a Transaction object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>In Aedis there is no difference between sending one command, a pipeline or a transaction because requests are decoupled from the IO objects.</p>
<blockquote class="doxtable">
<p >&zwj;redis-plus-plus also supports async interface, however, async support for Transaction and Subscriber is still on the way.</p>
<p >The async interface depends on third-party event library, and so far, only libuv is supported. </p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_redis = AsyncRedis(opts, pool_opts);</div>
<div class="line"> </div>
<div class="line">Future&lt;string&gt; ping_res = async_redis.ping();</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; ping_res.get() &lt;&lt; endl;</div>
</div><!-- fragment --><p> As the reader can see, the async interface is based on futures which is also known to have a bad performance. The biggest problem however with this async design is that it makes it impossible to write asynchronous programs correctly since it starts an async operation on every command sent instead of enqueueing a message and triggering a write when it can be sent. It is also not clear how are pipelines realised with this design (if at all).</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Echo server benchmark</h2>
<p >This document benchmarks the performance of TCP echo servers I implemented in different languages using different Redis clients. The main motivations for choosing an echo server are</p>
<ul>
<li>Simple to implement and does not require expertise level in most languages.</li>
<li>I/O bound: Echo servers have very low CPU consumption in general and therefore are excelent to measure how a program handles concurrent requests.</li>
<li>It simulates very well a typical backend in regard to concurrency.</li>
</ul>
<p >I also imposed some constraints on the implementations</p>
<ul>
<li>It should be simple enough and not require writing too much code.</li>
<li>Favor the use standard idioms and avoid optimizations that require expert level.</li>
<li>Avoid the use of complex things like connection and thread pool.</li>
</ul>
<p >To reproduce these results run one of the echo-server programs in one terminal and the <a href="https://github.com/mzimbres/aedis/blob/42880e788bec6020dd018194075a211ad9f339e8/benchmarks/cpp/asio/echo_server_client.cpp">echo-server-client</a> in another.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Without Redis</h3>
<p >First I tested a pure TCP echo server, i.e. one that sends the messages directly to the client without interacting with Redis. The result can be seen below</p>
<p ><img src="https://mzimbres.github.io/aedis/tcp-echo-direct.png" alt="" class="inline"/></p>
<p >The tests were performed with a 1000 concurrent TCP connections on the localhost where latency is 0.07ms on average on my machine. On higher latency networks the difference among libraries is expected to decrease.</p>
<ul>
<li>I expected Libuv to have similar performance to Asio and Tokio.</li>
<li>I did expect nodejs to come a little behind given it is is javascript code. Otherwise I did expect it to have similar performance to libuv since it is the framework behind it.</li>
<li>Go did surprise me: faster than nodejs and libuv!</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/cpp/asio/echo_server_direct.cpp">Asio</a>: A variation of <a href="https://github.com/chriskohlhoff/asio/blob/4915cfd8a1653c157a1480162ae5601318553eb8/asio/src/examples/cpp20/coroutines/echo_server.cpp">this</a> Asio example.</li>
<li><a href="https://github.com/mzimbres/aedis/tree/835a1decf477b09317f391eddd0727213cdbe12b/benchmarks/c/libuv">Libuv</a>: Taken from <a href="https://github.com/libuv/libuv/blob/06948c6ee502862524f233af4e2c3e4ca876f5f6/docs/code/tcp-echo-server/main.c">here</a> Libuv example .</li>
<li><a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/rust/echo_server_direct">Tokio</a>: Taken from <a href="https://docs.rs/tokio/latest/tokio/">here</a>.</li>
<li><a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_direct">Nodejs</a></li>
<li><a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_direct.go">Go</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
With Redis</h3>
<p >This is similar to the echo server described above but messages are echoed by Redis and not by the echo-server itself, which acts as a proxy between the client and the Redis server. The results can be seen below</p>
<p ><img src="https://mzimbres.github.io/aedis/tcp-echo-over-redis.png" alt="" class="inline"/></p>
<p >The tests were performed on a network where latency is 35ms on average, otherwise it uses the same number of TCP connections as the previous example.</p>
<p >As the reader can see, the Libuv and the Rust test are not depicted in the graph, the reasons are</p>
<ul>
<li><a href="https://github.com/redis-rs/redis-rs">redis-rs</a>: This client comes so far behind that it can't even be represented together with the other benchmarks without making them look insignificant. I don't know for sure why it is so slow, I suppose it has something to do with its lack of automatic <a href="https://redis.io/docs/manual/pipelining/">pipelining</a> support. In fact, the more TCP connections I lauch the worse its performance gets.</li>
<li>Libuv: I left it out because it would require me writing to much c code. More specifically, I would have to use hiredis and implement support for pipelines manually.</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/mzimbres/aedis">Aedis</a>: <a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/examples/echo_server.cpp">code</a></li>
<li><a href="https://github.com/redis/node-redis">node-redis</a>: <a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_over_redis">code</a></li>
<li><a href="https://github.com/go-redis/redis">go-redis</a>: <a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_over_redis.go">code</a></li>
</ul>
<p ><a class="anchor" id="api-reference"></a></p>
<h3><a class="anchor" id="autotoc_md19"></a>
Conclusion</h3>
<p >Redis clients have to support automatic pipelining to have competitive performance. For updates to this document follow <a href="https://github.com/mzimbres/aedis">https://github.com/mzimbres/aedis</a>.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Reference</h1>
<ul>
<li><a class="el" href="group__high-level-api.html">High-Level</a>: Covers the topics discussed in this document.</li>
<li><a class="el" href="group__low-level-api.html">Low-Level</a>: Covers low-level building blocks. Provided mostly for developers, most users won't need any information provided here.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Installation</h1>
<p >Download the latest release on <a href="https://github.com/mzimbres/aedis/releases">https://github.com/mzimbres/aedis/releases</a>. Aedis is a header only library, so you can starting using it right away by adding the <code>include</code> subdirectory to your project and including</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;aedis/src.hpp&gt;</span></div>
</div><!-- fragment --><p >in no more than one source file in your applications. To build the examples and test cmake is supported, for example</p>
<div class="fragment"><div class="line">BOOST_ROOT=/opt/boost_1_80_0 cmake --preset dev</div>
</div><!-- fragment --><p >The requirements for using Aedis are</p>
<ul>
<li>Boost 1.80 or greater.</li>
<li>C++17 minimum.</li>
<li>Redis 6 or higher (must support RESP3).</li>
<li>Optionally also redis-cli and Redis Sentinel.</li>
</ul>
<p >The following compilers are supported</p>
<ul>
<li>Tested with gcc: 10, 11, 12.</li>
<li>Tested with clang: 11, 13, 14.</li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
Acknowledgement</h1>
<p >Acknowledgement to people that helped shape Aedis</p>
<ul>
<li>Richard Hodges (<a href="https://github.com/madmongo1">madmongo1</a>): For very helpful support with Asio, the design of asynchronous programs, etc.</li>
<li>Vinícius dos Santos Oliveira (<a href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful discussion about how Aedis consumes buffers in the read operation.</li>
<li>Petr Dannhofer (<a href="https://github.com/Eddie-cz">Eddie-cz</a>): For helping me understand how the <code>AUTH</code> and <code>HELLO</code> command can influence each other.</li>
<li>Mohammad Nejati (<a href="https://github.com/ashtum">ashtum</a>): For pointing out scenarios where calls to <code>async_exec</code> should fail when the connection is lost.</li>
<li>Klemens Morgenstern (<a href="https://github.com/klemens-morgenstern">klemens-morgenstern</a>): For useful discussion about timeouts, cancellation, synchronous interfaces and general help with Asio.</li>
</ul>
<h1><a class="anchor" id="autotoc_md23"></a>
Changelog</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
v1.3.0-1</h2>
<ul>
<li>Removes automatic sending of the <code>HELLO</code> command. This can't be implemented properly without bloating the connection class. It is now a user responsability to send HELLO. Requests that contain it have priority over other requests and will be moved to the front of the queue, see <code><a class="el" href="classaedis_1_1resp3_1_1request.html#structaedis_1_1resp3_1_1request_1_1config" title="Request configuration options.">aedis::resp3::request::config</a></code></li>
<li>Automatic name resolving and connecting have been removed from <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code>. Users have to do this step manually now. The reason for this change is that having them built-in doesn't offer enough flexibility that is need for boost users.</li>
<li>Removes healthy checks and idle timeout. This functionality must now be implemented by users, see the examples. This is part of making Aedis useful to a larger audience and suitable for the Boost review process.</li>
<li>The <code>aedis::connection</code> is now using a typeddef to a <code>net::ip::tcp::socket</code> and <code>aedis::ssl::connection</code> to <code>net::ssl::stream&lt;net::ip::tcp::socket&gt;</code>. Users that need to use other stream type must now specialize <code><a class="el" href="classaedis_1_1basic__connection.html" title="A connection to the Redis server.">aedis::basic_connection</a></code>.</li>
<li>Adds a low level example of async code.</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
v1.2.0</h2>
<ul>
<li><code>aedis::adapt</code> supports now tuples created with <code>std::tie</code>. <code>aedis::ignore</code> is now an alias to the type of <code>std::ignore</code>.</li>
<li>Provides allocator support for the internal queue used in the <code>aedis::connection</code> class.</li>
<li>Changes the behaviour of <code>async_run</code> to complete with success if asio::error::eof is received. This makes it easier to write composed operations with awaitable operators.</li>
<li>Adds allocator support in the <code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code> (a contribution from Klemens Morgenstern).</li>
<li>Renames <code>aedis::resp3::request::push_range2</code> to <code>push_range</code>. The suffix 2 was used for disambiguation. Klemens fixed it with SFINAE.</li>
<li>Renames <code>fail_on_connection_lost</code> to <code><a class="el" href="classaedis_1_1resp3_1_1request.html#aab978e56c202631d2fea293b73725e69" title="If true the request will complete with error if the connection is lost while the request is pending....">aedis::resp3::request::config::cancel_on_connection_lost</a></code>. Now, it will only cause connections to be canceled when <code>async_run</code> completes.</li>
<li>Introduces <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a4054811af1ac8f14a04a501907bc05be" title="If true, the request will complete with error if the call happens before the connection with Redis wa...">aedis::resp3::request::config::cancel_if_not_connected</a></code> which will cause a request to be canceled if <code>async_exec</code> is called before a connection has been established.</li>
<li>Introduces new request flag <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a653d47ba62bd2b3f84f424a2b2b35b9a" title="If true, the implementation will resend this request if it remains unresponded when aedis::connection...">aedis::resp3::request::config::retry</a></code> that if set to true will cause the request to not be canceled when it was sent to Redis but remained unresponded after <code>async_run</code> completed. It provides a way to avoid executing commands twice.</li>
<li>Removes the <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> overload that takes request and adapter as parameters.</li>
<li>Changes the way <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> behaves with <code>std::vector&lt;<a class="el" href="structaedis_1_1resp3_1_1node.html" title="A node in the response tree.">aedis::resp3::node</a>&lt;T&gt;&gt;</code>. Receiving RESP3 simple errors, blob errors or null won't causes an error but will be treated as normal response. It is the user responsibility to check the content in the vector.</li>
<li>Fixes a bug in <code>connection::cancel(operation::exec)</code>. Now this call will only cancel non-written requests.</li>
<li>Implements per-operation implicit cancellation support for <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">aedis::connection::async_exec</a></code>. The following call will <code>co_await (conn.async_exec(...) || timer.async_wait(...))</code> will cancel the request as long as it has not been written.</li>
<li>Changes <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> completion signature to <code>f(error_code)</code>. This is how is was in the past, the second parameter was not helpful.</li>
<li>Renames <code>operation::receive_push</code> to <code><a class="el" href="group__high-level-api.html#ggadcfe42e0996c05d14fe5f8bacce384bcacbd71f0d3114139d38a8d080d610e5fd" title="Refers to connection::async_receive operations.">aedis::operation::receive</a></code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
v1.1.0-1</h2>
<ul>
<li>Removes <code>coalesce_requests</code> from the <code>aedis::connection::config</code>, it became a request property now, see <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a253cef2ca5d60b1b319019fafb3d27b3" title="If true the request will be coalesced with other requests, see https://redis.io/topics/pipelining....">aedis::resp3::request::config::coalesce</a></code>.</li>
<li>Removes <code>max_read_size</code> from the <code>aedis::connection::config</code>. The maximum read size can be specified now as a parameter of the <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> function.</li>
<li>Removes <code>aedis::sync</code> class, see <a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a> for how to perform synchronous and thread safe calls. This is possible in Boost. 1.80 only as it requires <code>boost::asio::deferred</code>.</li>
<li>Moves from <code>boost::optional</code> to <code>std::optional</code>. This is part of moving to C++17.</li>
<li>Changes the behaviour of the second <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> overload so that it always returns an error when the connection is lost.</li>
<li>Adds TLS support, see <a class="el" href="intro__tls_8cpp_source.html">intro_tls.cpp</a>.</li>
<li>Adds an example that shows how to resolve addresses over sentinels, see subscriber_sentinel.cpp.</li>
<li>Adds a <code>aedis::connection::timeouts::resp3_handshake_timeout</code>. This is timeout used to send the <code>HELLO</code> command.</li>
<li>Adds <code>aedis::endpoint</code> where in addition to host and port, users can optionally provide username, password and the expected server role (see <code>aedis::error::unexpected_server_role</code>).</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> checks whether the server role received in the hello command is equal to the expected server role specified in <code>aedis::endpoint</code>. To skip this check let the role variable empty.</li>
<li>Removes reconnect functionality from <code>aedis::connection</code>. It is possible in simple reconnection strategies but bloats the class in more complex scenarios, for example, with sentinel, authentication and TLS. This is trivial to implement in a separate coroutine. As a result the enum <code>event</code> and <code>async_receive_event</code> have been removed from the class too.</li>
<li>Fixes a bug in <code>connection::async_receive_push</code> that prevented passing any response adapter other that <code>adapt(std::vector&lt;node&gt;)</code>.</li>
<li>Changes the behaviour of <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> that caused RESP3 errors to be ignored. One consequence of it is that <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> would not exit with failure in servers that required authentication.</li>
<li>Changes the behaviour of <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> that would cause it to complete with success when an error in the <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> occurred.</li>
<li>Ports the buildsystem from autotools to CMake.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
v1.0.0</h2>
<ul>
<li>Adds experimental cmake support for windows users.</li>
<li>Adds new class <code>aedis::sync</code> that wraps an <code>aedis::connection</code> in a thread-safe and synchronous API. All free functions from the <code>sync.hpp</code> are now member functions of <code>aedis::sync</code>.</li>
<li>Split <code>aedis::connection::async_receive_event</code> in two functions, one to receive events and another for server side pushes, see <code>aedis::connection::async_receive_push</code>.</li>
<li>Removes collision between <code>aedis::adapter::adapt</code> and <code>aedis::adapt</code>.</li>
<li>Adds <code>connection::operation</code> enum to replace <code>cancel_*</code> member functions with a single cancel function that gets the operations that should be cancelled as argument.</li>
<li>Bugfix: a bug on reconnect from a state where the <code>connection</code> object had unsent commands. It could cause <code>async_exec</code> to never complete under certain conditions.</li>
<li>Bugfix: Documentation of <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">adapt()</a></code> functions were missing from Doxygen.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
v0.3.0</h2>
<ul>
<li>Adds <code>experimental::exec</code> and <code>receive_event</code> functions to offer a thread safe and synchronous way of executing requests across threads. See <code><a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a></code> and <code>subscriber_sync.cpp</code> for examples.</li>
<li><code>connection::async_read_push</code> was renamed to <code>async_receive_event</code>.</li>
<li><code>connection::async_receive_event</code> is now being used to communicate internal events to the user, such as resolve, connect, push etc. For examples see <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a> and <code>connection::event</code>.</li>
<li>The <code>aedis</code> directory has been moved to <code>include</code> to look more similar to Boost libraries. Users should now replace <code>-I/aedis-path</code> with <code>-I/aedis-path/include</code> in the compiler flags.</li>
<li>The <code>AUTH</code> and <code>HELLO</code> commands are now sent automatically. This change was necessary to implement reconnection. The username and password used in <code>AUTH</code> should be provided by the user on <code>connection::config</code>.</li>
<li>Adds support for reconnection. See <code>connection::enable_reconnect</code>.</li>
<li>Fixes a bug in the <code>connection::async_run(host, port)</code> overload that was causing crashes on reconnection.</li>
<li>Fixes the executor usage in the connection class. Before theses changes it was imposing <code>any_io_executor</code> on users.</li>
<li><code>connection::async_receiver_event</code> is not cancelled anymore when <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> exits. This change makes user code simpler.</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> with host and port overload has been removed. Use the other <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> overload.</li>
<li>The host and port parameters from <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> have been move to <code>connection::config</code> to better support authentication and failover.</li>
<li>Many simplifications in the <code>chat_room</code> example.</li>
<li>Fixes build in clang the compilers and makes some improvements in the documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
v0.2.0-1</h2>
<ul>
<li>Fixes a bug that happens on very high load. (v0.2.1)</li>
<li>Major rewrite of the high-level API. There is no more need to use the low-level API anymore.</li>
<li>No more callbacks: Sending requests follows the ASIO asynchronous model.</li>
<li>Support for reconnection: Pending requests are not canceled when a connection is lost and are re-sent when a new one is established.</li>
<li>The library is not sending HELLO-3 on user behalf anymore. This is important to support AUTH properly.</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
v0.1.0-2</h2>
<ul>
<li>Adds reconnect coroutine in the <code>echo_server</code> example. (v0.1.2)</li>
<li>Corrects <code>client::async_wait_for_data</code> with <code>make_parallel_group</code> to launch operation. (v0.1.2)</li>
<li>Improvements in the documentation. (v0.1.2)</li>
<li>Avoids dynamic memory allocation in the client class after reconnection. (v0.1.2)</li>
<li>Improves the documentation and adds some features to the high-level client. (v.0.1.1)</li>
<li>Improvements in the design and documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
v0.0.1</h2>
<ul>
<li>First release to collect design feedback. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
Author: Marcelo Zimbres Silva.
</address>
</body>
</html>
