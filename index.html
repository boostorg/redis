<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aedis: Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aedis.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="6">
 <tbody>
 <tr>
  <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">Aedis 1.0.0</font> &#160; <br> High level Redis client </td>
  <td style="width:100%">         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Overview">Overview</a><ul><li class="level2"><a href="#Async">Async</a></li>
<li class="level2"><a href="#Sync">Sync</a></li>
<li class="level2"><a href="#using-aedis">Installation</a><ul><li class="level3"><a href="#using_aedis">Using Aedis</a></li>
<li class="level3"><a href="#sup-comp">Supported compilers</a></li>
<li class="level3"><a href="#Developers">Developers</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#requests">Requests</a><ul><li class="level2"><a href="#requests-serialization">Serialization</a></li>
</ul>
</li>
<li class="level1"><a href="#low-level-responses">Responses</a><ul><li class="level2"><a href="#Optional">Optional</a></li>
<li class="level2"><a href="#transactions">Transactions</a></li>
<li class="level2"><a href="#Deserialization">Deserialization</a></li>
<li class="level2"><a href="#gen-case">The general case</a></li>
</ul>
</li>
<li class="level1"><a href="#examples">Examples</a></li>
<li class="level1"><a href="#why-aedis">Why Aedis</a><ul><li class="level2"><a href="#redis-plus-plus">redis-plus-plus</a></li>
</ul>
</li>
<li class="level1"><a href="#Acknowledgement">Acknowledgement</a></li>
</ul>
</div>
<div class="textblock"><p>Useful links: <a class="el" href="group__any.html">Reference</a>, <a class="el" href="md_CHANGELOG.html">Changelog</a> and <a class="el" href="md_benchmarks_benchmarks.html">Benchmarks</a>.</p>
<h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>Aedis is a high-level <a href="https://redis.io/">Redis</a> client library built on top of <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Asio</a>. Some of its distinctive features are</p>
<ul>
<li>Support for the latest version of the Redis communication protocol <a href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>. </li>
<li>First class support for STL containers and C++ built-in types. </li>
<li>Serialization and deserialization of your own data types. </li>
<li>Healthy checks, back pressure and low latency. </li>
<li>Hides most of the low level asynchronous operations away from the user.</li>
</ul>
<p>Let us have a look a some code snippets</p>
<h2><a class="anchor" id="Async"></a>
Async</h2>
<p>The code below sends a ping command to Redis and quits (see <a class="el" href="intro_8cpp_source.html">intro.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   net::io_context ioc;</div>
<div class="line">   <a class="code" href="classaedis_1_1connection.html">connection</a> db{ioc};</div>
<div class="line"> </div>
<div class="line">   request req;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">   req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   std::tuple&lt;std::string, aedis::ignore&gt; resp;</div>
<div class="line">   db.<a class="code" href="classaedis_1_1connection.html#a7e1e03893cd5992d50577e353fbc304a">async_run</a>(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp), net::detached);</div>
<div class="line"> </div>
<div class="line">   ioc.run();</div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; std::get&lt;0&gt;(resp) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1connection_html"><div class="ttname"><a href="classaedis_1_1connection.html">aedis::connection</a></div><div class="ttdoc">A high level connection to Redis.</div><div class="ttdef"><b>Definition:</b> <a href="connection_8hpp_source.html#l00045">connection.hpp:45</a></div></div>
<div class="ttc" id="aclassaedis_1_1connection_html_a7e1e03893cd5992d50577e353fbc304a"><div class="ttname"><a href="classaedis_1_1connection.html#a7e1e03893cd5992d50577e353fbc304a">aedis::connection::async_run</a></div><div class="ttdeci">auto async_run(CompletionToken token=CompletionToken{})</div><div class="ttdoc">Starts communication with the Redis server asynchronously.</div><div class="ttdef"><b>Definition:</b> <a href="connection_8hpp_source.html#l00271">connection.hpp:271</a></div></div>
<div class="ttc" id="agroup__any_html_ga80578c88398587d09fecc7c38fbf42ad"><div class="ttname"><a href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">aedis::adapt</a></div><div class="ttdeci">auto adapt() noexcept</div><div class="ttdoc">Creates an adapter that ignores responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00140">adapt.hpp:140</a></div></div>
</div><!-- fragment --><p>The connection class maintains a healthy connection with Redis over which users can execute their commands, without any need of queuing. For example, to execute more than one request</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">   net::io_context ioc;</div>
<div class="line">   <a class="code" href="classaedis_1_1connection.html">connection</a> db{ioc};</div>
<div class="line"> </div>
<div class="line">   db.<a class="code" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff">async_exec</a>(req1, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp1), handler1);</div>
<div class="line">   db.async_exec(req2, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp2), handler2);</div>
<div class="line">   db.async_exec(req3, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp3), handler3);</div>
<div class="line"> </div>
<div class="line">   db.async_run(net::detached);</div>
<div class="line"> </div>
<div class="line">   ioc.run();</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1connection_html_a74065e41d97eb1388f3d081b3195c4ff"><div class="ttname"><a href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff">aedis::connection::async_exec</a></div><div class="ttdeci">auto async_exec(resp3::request const &amp;req, Adapter adapter=adapt(), CompletionToken token=CompletionToken{})</div><div class="ttdoc">Executes a command on the redis server asynchronously.</div><div class="ttdef"><b>Definition:</b> <a href="connection_8hpp_source.html#l00335">connection.hpp:335</a></div></div>
</div><!-- fragment --><p>The <code><a class="el" href="classaedis_1_1connection.html#a74065e41d97eb1388f3d081b3195c4ff" title="Executes a command on the redis server asynchronously.">connection::async_exec</a></code> functions above can be called from different places in the code without knowing about each other, see for example <a class="el" href="echo__server_8cpp_source.html">echo_server.cpp</a>. Server-side pushes are supported on the same connection where commands are executed, a typical subscriber will look like (see <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>)</p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; reader(std::shared_ptr&lt;connection&gt; db)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">for</span> (std::vector&lt;node_type&gt; resp;;) {</div>
<div class="line">      co_await db-&gt;async_receive_event(<a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
<div class="line">      <span class="comment">// Use resp and clear it.</span></div>
<div class="line">      resp.clear();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Sync"></a>
Sync</h2>
<p>The <code>connection</code> class offers only an asynchronous API. Synchronous communications with redis is provided by the <code><a class="el" href="classaedis_1_1sync.html" title="A high level synchronous connection to Redis.">aedis::sync</a></code> wrapper class. (see <a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   net::io_context ioc{1};</div>
<div class="line">   <span class="keyword">auto</span> work = net::make_work_guard(ioc);</div>
<div class="line">   std::thread t1{[&amp;]() { ioc.run(); }};</div>
<div class="line"> </div>
<div class="line">   sync&lt;connection&gt; conn{work.get_executor()};</div>
<div class="line">   std::thread t2{[&amp;]() { boost::system::error_code ec; conn.run(ec); }};</div>
<div class="line"> </div>
<div class="line">   request req;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">   req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   std::tuple&lt;std::string, aedis::ignore&gt; resp;</div>
<div class="line">   conn.exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Response: &quot;</span> &lt;&lt; std::get&lt;0&gt;(resp) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">   work.reset();</div>
<div class="line"> </div>
<div class="line">   t1.join();</div>
<div class="line">   t2.join();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="using-aedis"></a>
Installation</h2>
<p>To install and use Aedis you will need</p>
<ul>
<li>Boost 1.78 or greater.</li>
<li>C++17. Some examples require C++20 with coroutine support.</li>
<li>Redis 6 or higher. Optionally also redis-cli and Redis Sentinel.</li>
</ul>
<p>For a simple installation run</p>
<div class="fragment"><div class="line">$ git clone --branch v1.0.0 https:<span class="comment">//github.com/mzimbres/aedis.git</span></div>
<div class="line">$ cd aedis</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Option 1: Direct compilation.</span></div>
<div class="line">$ g++ -std=c++17 -pthread examples/intro.cpp -I./include -I/path/boost_1_79_0/include/</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Option 2: Use cmake.</span></div>
<div class="line"><span class="preprocessor">$ BOOST_ROOT=/opt/boost_1_79_0/ cmake -DCMAKE_CXX_FLAGS=-std=c++20 .</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>CMake support is still experimental.</dd></dl>
<p>For a proper full installation on the system run</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Download and unpack the latest release</span></div>
<div class="line">$ wget https:<span class="comment">//github.com/mzimbres/aedis/releases/download/v1.0.0/aedis-1.0.0.tar.gz</span></div>
<div class="line">$ tar -xzvf aedis-1.0.0.tar.gz</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Configure, build and install</span></div>
<div class="line">$ CXXFLAGS=<span class="stringliteral">&quot;-std=c++17&quot;</span> ./configure --prefix=/opt/aedis-1.0.0 --with-boost=/opt/boost_1_78_0</div>
<div class="line">$ sudo make install</div>
</div><!-- fragment --><p>To build examples and tests</p>
<div class="fragment"><div class="line">$ make</div>
</div><!-- fragment --><h3><a class="anchor" id="using_aedis"></a>
Using Aedis</h3>
<p>When writing you own applications include the following header</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;aedis/src.hpp&gt;</span></div>
</div><!-- fragment --><p>in no more than one source file in your applications.</p>
<h3><a class="anchor" id="sup-comp"></a>
Supported compilers</h3>
<p>Aedis has been tested with the following compilers</p>
<ul>
<li>Tested with gcc: 12, 11.</li>
<li>Tested with clang: 14, 13, 11.</li>
</ul>
<h3><a class="anchor" id="Developers"></a>
Developers</h3>
<p>To generate the build system clone the repository and run</p>
<div class="fragment"><div class="line"><span class="preprocessor"># git clone https:</span><span class="comment">//github.com/mzimbres/aedis.git</span></div>
<div class="line">$ autoreconf -i</div>
</div><!-- fragment --><p>After that we get a configure script that can be run as explained above, for example, to build with a compiler other that the system compiler with coverage support run</p>
<div class="fragment"><div class="line">$ CXX=clang++-14 \</div>
<div class="line">  CXXFLAGS=<span class="stringliteral">&quot;-g -std=c++20 -Wall -Wextra --coverage -fkeep-inline-functions -fkeep-static-functions&quot;</span> \</div>
<div class="line">  LDFLAGS=<span class="stringliteral">&quot;--coverage&quot;</span> \</div>
<div class="line">  ./configure --with-boost=/opt/boost_1_79_0</div>
</div><!-- fragment --><p>To generate release tarballs run</p>
<div class="fragment"><div class="line">$ make distcheck</div>
</div><!-- fragment --><h1><a class="anchor" id="requests"></a>
Requests</h1>
<p>Redis requests are composed of one of more Redis commands (in Redis documentation they are called <a href="https://redis.io/topics/pipelining">pipelines</a>). For example</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with variable length of arguments.</span></div>
<div class="line">req.push(<span class="stringliteral">&quot;SET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;some value&quot;</span>, value, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a list.</span></div>
<div class="line">std::list&lt;std::string&gt; list</div>
<div class="line">   {<span class="stringliteral">&quot;channel1&quot;</span>, <span class="stringliteral">&quot;channel2&quot;</span>, <span class="stringliteral">&quot;channel3&quot;</span>};</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but as an iterator range.</span></div>
<div class="line">req.push_range2(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, std::cbegin(list), std::cend(list));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a map.</span></div>
<div class="line">std::map&lt;std::string, mystruct&gt; <a class="code" href="group__any.html#ggabdb6bdf6f96b4a7a91ed63d2324cef57a1d78dc8ed51214e518b5114fe24490ae">map</a></div>
<div class="line">   { {<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>}</div>
<div class="line">   , {<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>}</div>
<div class="line">   , {<span class="stringliteral">&quot;key3&quot;</span>, <span class="stringliteral">&quot;value3&quot;</span>}};</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
<div class="ttc" id="agroup__any_html_ggabdb6bdf6f96b4a7a91ed63d2324cef57a1d78dc8ed51214e518b5114fe24490ae"><div class="ttname"><a href="group__any.html#ggabdb6bdf6f96b4a7a91ed63d2324cef57a1d78dc8ed51214e518b5114fe24490ae">aedis::resp3::type::map</a></div><div class="ttdeci">@ map</div><div class="ttdoc">Aggregate.</div></div>
</div><!-- fragment --><p>Sending a request to Redis is then peformed with the following function</p>
<div class="fragment"><div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
</div><!-- fragment --><h2><a class="anchor" id="requests-serialization"></a>
Serialization</h2>
<p>The <code>push</code> and <code>push_range</code> functions above work with integers e.g. <code>int</code> and <code>std::string</code> out of the box. To send your own data type defined a <code>to_bulk</code> function like this</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mystruct {</div>
<div class="line">   <span class="comment">// Example struct.</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classaedis_1_1resp3_1_1request.html#a30ed6048af1b522f52d7e0e53eac4332">to_bulk</a>(std::string&amp; to, mystruct <span class="keyword">const</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">   std::string dummy = <span class="stringliteral">&quot;Dummy serializaiton string.&quot;</span>;</div>
<div class="line">   aedis::resp3::to_bulk(to, dummy);</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1resp3_1_1request_html_a30ed6048af1b522f52d7e0e53eac4332"><div class="ttname"><a href="classaedis_1_1resp3_1_1request.html#a30ed6048af1b522f52d7e0e53eac4332">aedis::resp3::request::to_bulk</a></div><div class="ttdeci">void to_bulk(Request &amp;to, boost::string_view data)</div><div class="ttdoc">Adds a bulk to the request.</div><div class="ttdef"><b>Definition:</b> <a href="request_8hpp_source.html#l00049">request.hpp:49</a></div></div>
</div><!-- fragment --><p>Once <code>to_bulk</code> is defined and accessible over ADL <code>mystruct</code> can be passed to the <code>request</code> </p>
<div class="fragment"><div class="line">request req;</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, mystruct&gt; <a class="code" href="group__any.html#ggabdb6bdf6f96b4a7a91ed63d2324cef57a1d78dc8ed51214e518b5114fe24490ae">map</a> {...};</div>
<div class="line"> </div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p>Example <a class="el" href="serialization_8cpp_source.html">serialization.cpp</a> shows how store json string in Redis.</p>
<h1><a class="anchor" id="low-level-responses"></a>
Responses</h1>
<p>To read responses effectively, users must know their RESP3 type, this can be found in the Redis documentation for each command (<a href="https://redis.io/commands">https://redis.io/commands</a>). For example</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lpush   </td><td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lrange   </td><td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set   </td><td class="markdownTableBodyNone">Simple-string, null or blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/set">https://redis.io/commands/set</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">get   </td><td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/get">https://redis.io/commands/get</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">smembers   </td><td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hgetall   </td><td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a>   </td></tr>
</table>
<p>Once the RESP3 type of a given response is known we can choose a proper C++ data structure to receive it in. Fortunately, this is a simple task for most types. The table below summarises the options</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Possible C++ type   </th><th class="markdownTableHeadNone">Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple-string   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple-error   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blob-error   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><code>long long</code>, <code>int</code>, <code>std::size_t</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone"><code>double</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Null   </td><td class="markdownTableBodyNone"><code>boost::optional&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::list</code>, <code>std::array</code>, <code>std::deque</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::set</code>, <code>std::unordered_set</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Push   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate   </td></tr>
</table>
<p>For example</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;RPUSH&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>, vec);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, map);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key4&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code" href="group__any.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// hello</span></div>
<div class="line">   int,            <span class="comment">// rpush</span></div>
<div class="line">   int,            <span class="comment">// hset</span></div>
<div class="line">   std::vector&lt;T&gt;, <span class="comment">// lrange</span></div>
<div class="line">   std::map&lt;U, V&gt;, <span class="comment">// hgetall</span></div>
<div class="line">   std::string     <span class="comment">// quit</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
<div class="ttc" id="agroup__any_html_ga0d619e51ab37f7854e7218a061900820"><div class="ttname"><a href="group__any.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a></div><div class="ttdeci">adapter::detail::ignore ignore</div><div class="ttdoc">Tag used to ignore responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00035">adapt.hpp:35</a></div></div>
</div><!-- fragment --><p>The tag <code>aedis::ignore</code> can be used to ignore individual elements in the responses. If the intention is to ignore the response to all commands in the request use <code><a class="el" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad" title="Creates an adapter that ignores responses.">adapt()</a></code> </p>
<div class="fragment"><div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>());</div>
</div><!-- fragment --><p>Responses that contain nested aggregates or heterogeneous data types will be given special treatment later in <a class="el" href="index.html#gen-case">The general case</a>. As of this writing, not all RESP3 types are used by the Redis server, which means in practice users will be concerned with a reduced subset of the RESP3 specification.</p>
<h2><a class="anchor" id="Optional"></a>
Optional</h2>
<p>It is not uncommon for apps to access keys that do not exist or that have already expired in the Redis server, to deal with these cases Aedis provides support for <code>boost::optional</code>. To use it, wrap your type around <code>boost::optional</code> like this</p>
<div class="fragment"><div class="line">boost::optional&lt;std::unordered_map&lt;T, U&gt;&gt; resp;</div>
<div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
</div><!-- fragment --><p>Everything else stays the same.</p>
<h2><a class="anchor" id="transactions"></a>
Transactions</h2>
<p>To read the response to transactions we have to observe that Redis queues the commands as they arrive and sends the responses back to the user as an array, in the response to the <code>exec</code> command. For example, to read the response to the this request</p>
<div class="fragment"><div class="line">db.send(<span class="stringliteral">&quot;MULTI&quot;</span>);</div>
<div class="line">db.send(<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line">db.send(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, 0, -1);</div>
<div class="line">db.send(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>);</div>
<div class="line">db.send(<span class="stringliteral">&quot;EXEC&quot;</span>);</div>
</div><!-- fragment --><p>use the following response type</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__any.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>;</div>
<div class="line"><span class="keyword">using</span> boost::optional;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> exec_resp_type = </div>
<div class="line">   std::tuple&lt;</div>
<div class="line">      optional&lt;std::string&gt;, <span class="comment">// get</span></div>
<div class="line">      optional&lt;std::vector&lt;std::string&gt;&gt;, <span class="comment">// lrange</span></div>
<div class="line">      optional&lt;std::map&lt;std::string, std::string&gt;&gt; <span class="comment">// hgetall</span></div>
<div class="line">   &gt;;</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code" href="group__any.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// multi</span></div>
<div class="line">   <a class="code" href="group__any.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// get</span></div>
<div class="line">   <a class="code" href="group__any.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// lrange</span></div>
<div class="line">   <a class="code" href="group__any.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>,     <span class="comment">// hgetall</span></div>
<div class="line">   exec_resp_type, <span class="comment">// exec</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
</div><!-- fragment --><p>Note that above we are not ignoring the response to the commands themselves but whether they have been successfully queued. For a complete example see <a class="el" href="containers_8cpp_source.html">containers.cpp</a>.</p>
<h2><a class="anchor" id="Deserialization"></a>
Deserialization</h2>
<p>As mentioned in <a class="el" href="index.html#requests-serialization">Serialization</a>, it is common to serialize data before sending it to Redis e.g. to json strings. For performance and convenience reasons, we may also want to deserialize it directly in its final data structure. Aedis supports this use case by calling a user provided <code>from_bulk</code> function while parsing the response. For example</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> from_bulk(mystruct&amp; obj, <span class="keywordtype">char</span> <span class="keyword">const</span>* p, std::size_t size, boost::system::error_code&amp; ec)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Deserializes p into obj.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>After that, you can start receiving data efficiently in the desired types e.g. <code>mystruct</code>, <code>std::map&lt;std::string, mystruct&gt;</code> etc.</p>
<h2><a class="anchor" id="gen-case"></a>
The general case</h2>
<p>There are cases where responses to Redis commands won't fit in the model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose responses don't have a fixed RESP3 type. Expecting an <code>int</code> and receiving a blob-string will result in error. </li>
<li>RESP3 aggregates that contain nested aggregates can't be read in STL containers. </li>
<li>Transactions with a dynamic number of commands can't be read in a <code>std::tuple</code>.</li>
</ul>
<p>To deal with these cases Aedis provides the <code>resp3::node</code> type, that is the most general form of an element in a response, be it a simple RESP3 type or an aggregate. It is defined like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;</div>
<div class="line"><span class="keyword">struct </span>node {</div>
<div class="line">   <span class="comment">// The RESP3 type of the data in this node.</span></div>
<div class="line">   <a class="code" href="group__any.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">type</a> data_type;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The number of elements of an aggregate (or 1 for simple data).</span></div>
<div class="line">   std::size_t aggregate_size;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The depth of this node in the response tree.</span></div>
<div class="line">   std::size_t depth;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The actual data. For aggregate types this is always empty.</span></div>
<div class="line">   String value;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__any_html_gabdb6bdf6f96b4a7a91ed63d2324cef57"><div class="ttname"><a href="group__any.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">aedis::resp3::type</a></div><div class="ttdeci">type</div><div class="ttdoc">RESP3 data types.</div><div class="ttdef"><b>Definition:</b> <a href="type_8hpp_source.html#l00022">type.hpp:23</a></div></div>
</div><!-- fragment --><p>Any response to a Redis command can be received in a <code>std::vector&lt;node&lt;std::string&gt;&gt;</code>. The vector can be seen as a pre-order view of the response tree (<a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR</a>). Using it is no different than using other types</p>
<div class="fragment"><div class="line"><span class="comment">// Receives any RESP3 simple data type.</span></div>
<div class="line">node&lt;std::string&gt; resp;</div>
<div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Receives any RESP3 simple or aggregate data type.</span></div>
<div class="line">std::vector&lt;node&lt;std::string&gt;&gt; resp;</div>
<div class="line">co_await db-&gt;async_exec(req, <a class="code" href="group__any.html#ga80578c88398587d09fecc7c38fbf42ad">adapt</a>(resp));</div>
</div><!-- fragment --><p>For example, suppose we want to retrieve a hash data structure from Redis with <code>HGETALL</code>, some of the options are</p>
<ul>
<li><code>std::vector&lt;node&lt;std::string&gt;</code>: Works always. </li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all elements as string. </li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if you need the data as a <code>std::map</code> </li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing serialized data. Avoids temporaries and requires <code>from_bulk</code> for <code>U</code> and <code>V</code>.</li>
</ul>
<p>In addition to the above users can also use unordered versions of the containers. The same reasoning also applies to sets e.g. <code>SMEMBERS</code>.</p>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<p>The examples listed below cover most use cases presented in the documentation above.</p>
<ul>
<li><a class="el" href="intro_8cpp_source.html">intro.cpp</a>: Basic steps with Aedis. </li>
<li><a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a>: Synchronous version of <a class="el" href="intro_8cpp_source.html">intro.cpp</a>. </li>
<li><a class="el" href="containers_8cpp_source.html">containers.cpp</a>: Shows how to send and receive stl containers. </li>
<li><a class="el" href="serialization_8cpp_source.html">serialization.cpp</a>: Shows how to serialize your own types. </li>
<li><a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>: Shows how to use pubsub. </li>
<li><a class="el" href="subscriber__sync_8cpp_source.html">subscriber_sync.cpp</a>: Synchronous version of <a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>. </li>
<li><a class="el" href="echo__server_8cpp_source.html">echo_server.cpp</a>: A simple TCP echo server that uses coroutines. </li>
<li><a class="el" href="chat__room_8cpp_source.html">chat_room.cpp</a>: A simple chat room that uses coroutines.</li>
</ul>
<h1><a class="anchor" id="why-aedis"></a>
Why Aedis</h1>
<p>At the time of this writing there are seventeen Redis clients listed in the <a href="https://redis.io/docs/clients/#cpp">official</a> list. With so many clients available it is not unlikely that users are asking themselves why yet another one. In this section I will try to compare Aedis with the most popular clients and why we need Aedis. Notice however that this is ongoing work as comparing client objectively is difficult and time consuming.</p>
<p>The most popular client at the moment of this writing ranked by github stars is</p>
<ul>
<li><a href="https://github.com/sewenew/redis-plus-plus">https://github.com/sewenew/redis-plus-plus</a></li>
</ul>
<p>Before we start it is worth mentioning some of the things it does not support</p>
<ul>
<li>RESP3. Without RESP3 is impossible to support some important Redis features like client side caching, among other things. </li>
<li>Coroutines. </li>
<li>Reading responses directly in user data structures avoiding temporaries. </li>
<li>Error handling with error-code and exception overloads. </li>
<li>Healthy checks.</li>
</ul>
<p>The remaining points will be addressed individually.</p>
<h2><a class="anchor" id="redis-plus-plus"></a>
redis-plus-plus</h2>
<p>Let us first have a look at what sending a command a pipeline and a transaction look like</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> redis = Redis(<span class="stringliteral">&quot;tcp://127.0.0.1:6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send commands</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>); <span class="comment">// val is of type OptionalString.</span></div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending pipelines</span></div>
<div class="line"><span class="keyword">auto</span> pipe = redis.pipeline();</div>
<div class="line"><span class="keyword">auto</span> pipe_replies = pipe.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line">                        .get(<span class="stringliteral">&quot;key&quot;</span>)</div>
<div class="line">                        .rename(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;new-key&quot;</span>)</div>
<div class="line">                        .rpush(<span class="stringliteral">&quot;list&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>})</div>
<div class="line">                        .lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1)</div>
<div class="line">                        .exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse reply with reply type and index.</span></div>
<div class="line"><span class="keyword">auto</span> set_cmd_result = pipe_replies.get&lt;<span class="keywordtype">bool</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending a transaction</span></div>
<div class="line"><span class="keyword">auto</span> tx = redis.transaction();</div>
<div class="line"><span class="keyword">auto</span> tx_replies = tx.incr(<span class="stringliteral">&quot;num0&quot;</span>)</div>
<div class="line">                    .incr(<span class="stringliteral">&quot;num1&quot;</span>)</div>
<div class="line">                    .mget({<span class="stringliteral">&quot;num0&quot;</span>, <span class="stringliteral">&quot;num1&quot;</span>})</div>
<div class="line">                    .exec();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> incr_result0 = tx_replies.get&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. This makes auto-pipelining impossible. </li>
<li>Any Api that sends individual commands has a very restricted scope of usability and should be avoided for performance reasons. </li>
<li>The API imposes exceptions on users, no error-code overload is provided. </li>
<li>No way to reuse the buffer for new calls to e.g. <code>redis.get</code> in order to avoid further dynamic memory allocations. </li>
<li>Error handling of resolve and connection not clear.</li>
</ul>
<p>According to the documentation, pipelines in redis-plus-plus have the following characteristics</p>
<blockquote class="doxtable">
<p>NOTE: By default, creating a Pipeline object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>This is clearly a downside of the API as pipelines should be the default way of communicating and not an exception, paying such a high price for each pipeline imposes a severe cost in performance. Transactions also suffer from the very same problem.</p>
<blockquote class="doxtable">
<p>NOTE: Creating a Transaction object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>In Aedis there is no difference between sending one command, a pipeline or a transaction because requests are decoupled from the IO objects.</p>
<blockquote class="doxtable">
<p>redis-plus-plus also supports async interface, however, async support for Transaction and Subscriber is still on the way.</p>
<p>The async interface depends on third-party event library, and so far, only libuv is supported. </p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_redis = AsyncRedis(opts, pool_opts);</div>
<div class="line"> </div>
<div class="line">Future&lt;string&gt; ping_res = async_redis.ping();</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; ping_res.get() &lt;&lt; endl;</div>
</div><!-- fragment --><p>As the reader can see, the async interface is based on futures which is also known to have a bad performance. The biggest problem however with this async design is that it makes it impossible to write asynchronous programs correctly since it starts an async operation on every command sent instead of enqueueing a message and triggering a write when it can be sent. It is also not clear how are pipelines realised with the design (if at all).</p>
<h1><a class="anchor" id="Acknowledgement"></a>
Acknowledgement</h1>
<p>Some people that were helpful in the development of Aedis</p>
<ul>
<li>Richard Hodges (<a href="https://github.com/madmongo1">madmongo1</a>): For helping me with Asio and the design of asynchronous programs in general. </li>
<li>Vin√≠cius dos Santos Oliveira (<a href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful discussion about how Aedis consumes buffers in the read operation (among other things). </li>
<li>Petr Dannhofer (<a href="https://github.com/Eddie-cz">Eddie-cz</a>): For helping me understand how the <code>AUTH</code> and <code>HELLO</code> command can influence each other. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
Author: Marcelo Zimbres Silva.
</address>
</body>
</html>
