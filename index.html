<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aedis: Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aedis.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table bgcolor="#346295" cellspacing="0" cellpadding="6">
 <tbody>
 <tr>
  <td valign="middle" style="color: #FFFFFF" nowrap="nowrap"><font size="6">Aedis 0.1.2</font> &#160; <br> Low level Redis client library </td>
  <td style="width:100%">         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Overview">Overview</a></li>
<li class="level1"><a href="#low-level-api">Low-level API</a><ul><li class="level2"><a href="#requests">Requests</a><ul><li class="level3"><a href="#requests-serialization">Serialization</a></li>
</ul>
</li>
<li class="level2"><a href="#low-level-responses">Responses</a><ul><li class="level3"><a href="#Optional">Optional</a></li>
<li class="level3"><a href="#heterogeneous_aggregates">Heterogeneous aggregates</a></li>
<li class="level3"><a href="#Serialization">Serialization</a></li>
<li class="level3"><a href="#gen-case">The general case</a></li>
<li class="level3"><a href="#low-level-adapters">Adapters</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#high-level-api">High-level API</a><ul><li class="level2"><a href="#high-level-sending-cmds">Sending commands</a></li>
</ul>
</li>
<li class="level1"><a href="#examples">Examples</a></li>
<li class="level1"><a href="#using-aedis">Using Aedis</a><ul><li class="level2"><a href="#Installation">Installation</a></li>
<li class="level2"><a href="#Developers">Developers</a></li>
</ul>
</li>
<li class="level1"><a href="#why-aedis">Why Aedis</a><ul><li class="level2"><a href="#redis-plus-plus">redis-plus-plus</a></li>
</ul>
</li>
<li class="level1"><a href="#Acknowledgement">Acknowledgement</a></li>
<li class="level1"><a href="#Reference">Reference</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>Aedis is a <a href="https://redis.io/">Redis</a> client library built on top of <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Asio</a> that provides simple and efficient communication with a Redis server. Some of its distinctive features are</p>
<ul>
<li>Support for the latest version of the Redis communication protocol <a href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>. </li>
<li>First class support for STL containers and C++ built-in types. </li>
<li>Serialization and deserialization of your own data types that avoid unnecessary copies. </li>
<li>Support for Redis <a href="https://redis.io/docs/manual/sentinel">sentinel</a>. </li>
<li>Sync and async API.</li>
</ul>
<p>In addition to that, Aedis provides a high-level client that offers the following functionality</p>
<ul>
<li>Management of message queues. </li>
<li>Simplified handling of server pushes. </li>
<li>Zero asymptotic allocations by means of memory reuse. </li>
<li>Healthy checks.</li>
</ul>
<p>If you are interested in a detailed comparison of Redis clients and the design rationale behind Aedis jump to <a class="el" href="index.html#why-aedis">Why Aedis</a>. Now let us have a look at the low-level API.</p>
<h1><a class="anchor" id="low-level-api"></a>
Low-level API</h1>
<p>The low-level API is very useful for tasks that can be performed in short lived connections, for example, assume we want to perform the following steps</p>
<ul>
<li>Set the value of a Redis key. </li>
<li>Set the expiration of that key to two seconds. </li>
<li>Get and return its old value. </li>
<li>Quit</li>
</ul>
<p>The coroutine-based asynchronous implementation of the steps above look like</p>
<div class="fragment"><div class="line">net::awaitable&lt;std::string&gt; set(net::ip::tcp::endpoint ep)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// To make code less verbose</span></div>
<div class="line">   <span class="keyword">using</span> tcp_socket = net::use_awaitable_t&lt;&gt;::as_default_on_t&lt;net::ip::tcp::socket&gt;;</div>
<div class="line"> </div>
<div class="line">   tcp_socket socket{co_await net::this_coro::executor};</div>
<div class="line">   co_await socket.async_connect(ep);</div>
<div class="line"> </div>
<div class="line">   std::string buffer, response;</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">auto</span> sr = <a class="code" href="group__any.html#ga4142e05fc5f5241f8c076882443e6fd1">make_serializer</a>(request);</div>
<div class="line">   sr.push(command::hello, 3);</div>
<div class="line">   sr.push(command::set, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;Value&quot;</span>, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;get&quot;</span>);</div>
<div class="line">   sr.push(command::quit);</div>
<div class="line">   co_await net::async_write(socket, net::buffer(buffer));</div>
<div class="line">   buffer.clear();</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">auto</span> dbuffer = net::dynamic_buffer(read_buffer);</div>
<div class="line">   co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer); <span class="comment">// Hello ignored.</span></div>
<div class="line">   co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(response)); <span class="comment">// Set</span></div>
<div class="line">   co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer); <span class="comment">// Quit ignored.</span></div>
<div class="line"> </div>
<div class="line">   co_return response;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__any_html_ga1e40a9e5ab61e7980b4be74bf0d4943d"><div class="ttname"><a href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">aedis::adapter::adapt</a></div><div class="ttdeci">auto adapt() noexcept</div><div class="ttdoc">Creates a dummy response adapter.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00041">adapt.hpp:41</a></div></div>
<div class="ttc" id="agroup__any_html_ga4142e05fc5f5241f8c076882443e6fd1"><div class="ttname"><a href="group__any.html#ga4142e05fc5f5241f8c076882443e6fd1">aedis::generic::make_serializer</a></div><div class="ttdeci">auto make_serializer(std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;storage)</div><div class="ttdoc">Creates a serializer.</div><div class="ttdef"><b>Definition:</b> <a href="serializer_8hpp_source.html#l00195">serializer.hpp:195</a></div></div>
<div class="ttc" id="agroup__any_html_ga8a0d6c76b5faeeaa5ee5e2e4770cd181"><div class="ttname"><a href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">aedis::resp3::async_read</a></div><div class="ttdeci">auto async_read(AsyncReadStream &amp;stream, DynamicBuffer buffer, ResponseAdapter adapter=ResponseAdapter{}, CompletionToken &amp;&amp;token=boost::asio::default_completion_token_t&lt; typename AsyncReadStream::executor_type &gt;{})</div><div class="ttdoc">Reads a complete response to a Redis command asynchronously.</div><div class="ttdef"><b>Definition:</b> <a href="read_8hpp_source.html#l00174">read.hpp:174</a></div></div>
</div><!-- fragment --><p>The simplicity of the code above makes it self explanatory</p>
<ul>
<li>Connect to the Redis server. </li>
<li>Declare a <code>std::string</code> to hold the request and add some commands in it with a serializer. </li>
<li>Write the payload to the socket and read the responses in the same order they were sent. </li>
<li>Return the response to the user.</li>
</ul>
<p>The <code>hello</code> command above is always required and must be sent first as it informs we want to communicate over RESP3.</p>
<h2><a class="anchor" id="requests"></a>
Requests</h2>
<p>As stated above, requests are created by defining a storage object and a serializer that knows how to convert user data into valid RESP3 wire-format. They are composed of one or more commands (in Redis documentation they are called <a href="https://redis.io/topics/pipelining">pipelines</a>), which means users can add as many commands to the request as they like, a feature that aids performance.</p>
<p>The individual commands in a request assume many different forms</p>
<ul>
<li>With and without keys. </li>
<li>Variable length arguments. </li>
<li>Ranges. </li>
<li>etc.</li>
</ul>
<p>To account for all these variations, the <code>serializer</code> class offers some member functions, each of them with a couple of overloads, for example</p>
<div class="fragment"><div class="line"><span class="comment">// Some data to send to Redis.</span></div>
<div class="line">std::string value = <span class="stringliteral">&quot;some value&quot;</span>;</div>
<div class="line"> </div>
<div class="line">std::list&lt;std::string&gt; list {<span class="stringliteral">&quot;channel1&quot;</span>, <span class="stringliteral">&quot;channel2&quot;</span>, <span class="stringliteral">&quot;channel3&quot;</span>};</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, mystruct&gt; map</div>
<div class="line">   { {<span class="stringliteral">&quot;key1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>}</div>
<div class="line">   , {<span class="stringliteral">&quot;key2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>}</div>
<div class="line">   , {<span class="stringliteral">&quot;key3&quot;</span>, <span class="stringliteral">&quot;value3&quot;</span>}};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with no arguments</span></div>
<div class="line">sr.push(command::quit);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with variable lenght arguments.</span></div>
<div class="line">sr.push(command::set, <span class="stringliteral">&quot;key&quot;</span>, value, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sends a container, no key.</span></div>
<div class="line">sr.push_range(command::subscribe, list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but an iterator range.</span></div>
<div class="line">sr.push_range2(command::subscribe, std::cbegin(list), std::cend(list));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sends a container, with key.</span></div>
<div class="line">sr.push_range(command::hset, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but as iterator range.</span></div>
<div class="line">sr.push_range2(command::hset, <span class="stringliteral">&quot;key&quot;</span>, std::cbegin(map), std::cend(map));</div>
</div><!-- fragment --><p>Once all commands have been added to the request, we can write it as usual by writing the payload to the socket</p>
<div class="fragment"><div class="line">co_await net::async_write(socket, buffer(request));</div>
</div><!-- fragment --><h3><a class="anchor" id="requests-serialization"></a>
Serialization</h3>
<p>The <code>send</code> and <code>send_range</code> functions above work with integers e.g. <code>int</code> and <code>std::string</code> out of the box. To send your own data type defined the <code>to_bulk</code> function like this</p>
<div class="fragment"><div class="line"><span class="comment">// Example struct.</span></div>
<div class="line"><span class="keyword">struct </span>mystruct {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__any.html#ga4e21de126538a37995f90914afd51447">to_bulk</a>(std::string&amp; to, mystruct <span class="keyword">const</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Convert to obj string and call to_bulk (see also add_header</span></div>
<div class="line">   <span class="comment">// and add_separator)</span></div>
<div class="line">   <span class="keyword">auto</span> dummy = <span class="stringliteral">&quot;Dummy serializaiton string.&quot;</span>;</div>
<div class="line">   <a class="code" href="group__any.html#ga4e21de126538a37995f90914afd51447">aedis::resp3::to_bulk</a>(to, dummy);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, mystruct&gt; map</div>
<div class="line">   { {<span class="stringliteral">&quot;key1&quot;</span>, {...}}</div>
<div class="line">   , {<span class="stringliteral">&quot;key2&quot;</span>, {...}}</div>
<div class="line">   , {<span class="stringliteral">&quot;key3&quot;</span>, {...}}};</div>
<div class="line"> </div>
<div class="line">db.send_range(command::hset, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
<div class="ttc" id="agroup__any_html_ga4e21de126538a37995f90914afd51447"><div class="ttname"><a href="group__any.html#ga4e21de126538a37995f90914afd51447">aedis::resp3::to_bulk</a></div><div class="ttdeci">void to_bulk(Request &amp;to, boost::string_view data)</div><div class="ttdoc">Adds a bulk to the request.</div><div class="ttdef"><b>Definition:</b> <a href="compose_8hpp_source.html#l00040">compose.hpp:40</a></div></div>
</div><!-- fragment --><p>It is quite common to store json string in Redis for example.</p>
<h2><a class="anchor" id="low-level-responses"></a>
Responses</h2>
<p>To read responses effectively, users must know their RESP3 type, this can be found in the Redis documentation of each command (<a href="https://redis.io/commands">https://redis.io/commands</a>). For example</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lpush   </td><td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lrange   </td><td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set   </td><td class="markdownTableBodyNone">Simple-string, null or blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/set">https://redis.io/commands/set</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">get   </td><td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/get">https://redis.io/commands/get</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">smembers   </td><td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hgetall   </td><td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a>   </td></tr>
</table>
<p>Once the RESP3 type of a given response is known we can choose a proper C++ data structure to receive it in. Fortunately, this is a simple task for most types. The table below summarises the options</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">C++   </th><th class="markdownTableHeadNone">Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple-string   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple-error   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blob-error   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><code>long long</code>, <code>int</code>, <code>std::size_t</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone"><code>double</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Null   </td><td class="markdownTableBodyNone"><code>boost::optional&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::list</code>, <code>std::array</code>, <code>std::deque</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::set</code>, <code>std::unordered_set</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Push   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate   </td></tr>
</table>
<p>Responses that contain nested aggregates or heterogeneous data types will be given special treatment later. As of this writing, not all RESP3 types are used by the Redis server, which means in practice users will be concerned with a reduced subset of the RESP3 specification. Now let us see some examples</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> dbuffer = dynamic_buffer(buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// To ignore the response.</span></div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read in a std::string e.g. get.</span></div>
<div class="line">std::string str;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(str));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read in a long long e.g. rpush.</span></div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="group__any.html#ggabdb6bdf6f96b4a7a91ed63d2324cef57ab1bc248a7ff2b2e95569f56de68615df">number</a>;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(number));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read in a std::set e.g. smembers.</span></div>
<div class="line">std::set&lt;T, U&gt; set;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(set));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read in a std::map e.g. hgetall.</span></div>
<div class="line">std::map&lt;T, U&gt; set;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(map));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read in a std::unordered_map e.g. hgetall.</span></div>
<div class="line">std::unordered_map&lt;T, U&gt; umap;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(umap));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read in a std::vector e.g. lrange.</span></div>
<div class="line">std::vector&lt;T&gt; vec;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(vec));</div>
<div class="ttc" id="agroup__any_html_ggabdb6bdf6f96b4a7a91ed63d2324cef57ab1bc248a7ff2b2e95569f56de68615df"><div class="ttname"><a href="group__any.html#ggabdb6bdf6f96b4a7a91ed63d2324cef57ab1bc248a7ff2b2e95569f56de68615df">aedis::resp3::type::number</a></div><div class="ttdeci">@ number</div><div class="ttdoc">Simple.</div></div>
</div><!-- fragment --><p>In other words, it is straightforward, just pass the result of <code>adapt</code> to the read function and make sure the response data type is compatible with the data structure you are calling <code>adapter(...)</code> with. All standard C++ containers are supported by Aedis.</p>
<h3><a class="anchor" id="Optional"></a>
Optional</h3>
<p>It is not uncommon for apps to access keys that do not exist or that have already expired in the Redis server, to deal with these cases Aedis provides support for <code>boost::optional</code>. To use it, wrap your type around <code>boost::optional</code> like this</p>
<div class="fragment"><div class="line">boost::optional&lt;std::unordered_map&lt;T, U&gt;&gt; umap;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer), <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(umap));</div>
</div><!-- fragment --><p>Everything else stays the same, before accessing data, users will have to check or assert the optional contains a value.</p>
<h3><a class="anchor" id="heterogeneous_aggregates"></a>
Heterogeneous aggregates</h3>
<p>There are cases where Redis returns aggregates that contain heterogeneous data, for example, an array that contains integers, strings nested sets etc. Aedis supports reading such aggregates in a <code>std::tuple</code> efficiently as long as the they don't contain 3-order nested aggregates e.g. an array that contains an array of arrays. For example, to read the response to a <code>hello</code> command we can use the following response type.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> hello_type = std::tuple&lt;</div>
<div class="line">   std::string, std::string,</div>
<div class="line">   std::string, std::string,</div>
<div class="line">   std::string, int,</div>
<div class="line">   std::string, int,</div>
<div class="line">   std::string, std::string,</div>
<div class="line">   std::string, std::string,</div>
<div class="line">   std::string, std::vector&lt;std::string&gt;&gt;;</div>
</div><!-- fragment --><p>Transactions are another example where this feature is useful, for example, the response to the transaction below</p>
<div class="fragment"><div class="line">db.send(command::multi);</div>
<div class="line">db.send(command::get, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line">db.send(command::lrange, <span class="stringliteral">&quot;key2&quot;</span>, 0, -1);</div>
<div class="line">db.send(command::hgetall, <span class="stringliteral">&quot;key3&quot;</span>);</div>
<div class="line">db.send(command::exec);</div>
</div><!-- fragment --><p>can be read in the following way</p>
<div class="fragment"><div class="line">std::tuple&lt;</div>
<div class="line">   boost::optional&lt;std::string&gt;, <span class="comment">// Response to get</span></div>
<div class="line">   boost::optional&lt;std::vector&lt;std::string&gt;&gt;, <span class="comment">// Response to lrange</span></div>
<div class="line">   boost::optional&lt;std::map&lt;std::string, std::string&gt;&gt; <span class="comment">// Response to hgetall</span></div>
<div class="line">&gt; trans;</div>
<div class="line"> </div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer)); <span class="comment">// Ignore multi</span></div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer)); <span class="comment">// Ignore get</span></div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer)); <span class="comment">// Ignore lrange</span></div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer)); <span class="comment">// Ignore hgetall</span></div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer), <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(trans));</div>
</div><!-- fragment --><p>Note that above we are not ignoring the response to the commands themselves but whether they have been successfully queued. Only after <code>exec</code> is received Redis will execute them in sequence and send all responses together in an array.</p>
<h3><a class="anchor" id="Serialization"></a>
Serialization</h3>
<p>As mentioned in <a class="el" href="index.html#requests-serialization">Serialization</a>, it is common for users to serialized data before sending it to Redis e.g. json strings, for example</p>
<div class="fragment"><div class="line">sr.push(command::set, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;{&quot;</span>Server<span class="stringliteral">&quot;: &quot;</span>Redis<span class="stringliteral">&quot;}&quot;</span>); <span class="comment">// Unquoted for readability.</span></div>
<div class="line">sr.push(command::get, <span class="stringliteral">&quot;key&quot;</span>)</div>
</div><!-- fragment --><p>For performance and convenience reasons, we may want to avoid receiving the response to the <code>get</code> command above as a string just to convert it later to a e.g. deserialized json. To support this, Aedis calls a user defined <code>from_string</code> function while parsing the response. In simple terms, define your type</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>mystruct {</div>
<div class="line">   <span class="comment">// struct fields.</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>and deserialize it from a string in a function <code>from_string</code> with the following signature</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> from_string(mystruct&amp; obj, <span class="keywordtype">char</span> <span class="keyword">const</span>* p, std::size_t size, boost::system::error_code&amp; ec)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Deserializes p into obj.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>After that, you can start receiving data efficiently in the desired types e.g. <code>mystruct</code>, <code>std::map&lt;std::string, mystruct&gt;</code> etc.</p>
<h3><a class="anchor" id="gen-case"></a>
The general case</h3>
<p>As already mentioned, there are cases where responses to Redis commands won't fit in the model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose response don't have a fixed RESP3 type. Expecting an <code>int</code> and receiving a blob-string will result in error. </li>
<li>RESP3 aggregates that contain nested aggregates can't be read in STL containers. </li>
<li>Transactions with a dynamic number of commands can't be read in a <code>std::tuple</code>.</li>
</ul>
<p>To deal with these cases Aedis provides the <code>resp3::node</code> type, that is the most general form of an element in a response, be it a simple RESP3 type or an aggregate. It is defined like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;</div>
<div class="line"><span class="keyword">struct </span>node {</div>
<div class="line">   <span class="comment">// The RESP3 type of the data in this node.</span></div>
<div class="line">   <a class="code" href="group__any.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">type</a> data_type;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The number of elements of an aggregate (or 1 for simple data).</span></div>
<div class="line">   std::size_t aggregate_size;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The depth of this node in the response tree.</span></div>
<div class="line">   std::size_t depth;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The actual data. For aggregate types this is always empty.</span></div>
<div class="line">   String value;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__any_html_gabdb6bdf6f96b4a7a91ed63d2324cef57"><div class="ttname"><a href="group__any.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">aedis::resp3::type</a></div><div class="ttdeci">type</div><div class="ttdoc">RESP3 data types.</div><div class="ttdef"><b>Definition:</b> <a href="type_8hpp_source.html#l00022">type.hpp:23</a></div></div>
</div><!-- fragment --><p>Any response to a Redis command can be received in a <code>std::vector&lt;node&lt;std::string&gt;&gt;</code>. The vector can be seen as a pre-order view of the response tree (<a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR</a>). Using it is no different that using other types</p>
<div class="fragment"><div class="line"><span class="comment">// Receives any RESP3 simple data type.</span></div>
<div class="line">node&lt;std::string&gt; resp;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer), <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(resp));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Receives any RESP3 simple or aggregate data type.</span></div>
<div class="line">std::vector&lt;node&lt;std::string&gt;&gt; resp;</div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer), <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(resp));</div>
</div><!-- fragment --><p>For example, suppose we want to retrieve a hash data structure from Redis with <code>hgetall</code>, some of the options are</p>
<ul>
<li><code>std::vector&lt;node&lt;std::string&gt;</code>: Works always. </li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all elements as string. </li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if you need the data as a <code>std::map</code> </li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing serialized data. Avoids temporaries and requires <code>from_string</code> for <code>U</code> and <code>V</code>.</li>
</ul>
<p>In addition to the above users can also use unordered versions of the containers. The same reasoning also applies to sets e.g. <code>smembers</code>.</p>
<h3><a class="anchor" id="low-level-adapters"></a>
Adapters</h3>
<p>Users that are not satisfied with any of the options above can write their own adapters very easily. For example, the adapter below can be used to print incoming data to the screen.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> adapter = [](<a class="code" href="group__any.html#structaedis_1_1resp3_1_1node">resp3::node&lt;boost::string_view&gt;</a> <span class="keyword">const</span>&amp; nd, boost::system::error_code&amp;)</div>
<div class="line">{</div>
<div class="line">   std::cout &lt;&lt; nd &lt;&lt; std::endl;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">co_await <a class="code" href="group__any.html#ga8a0d6c76b5faeeaa5ee5e2e4770cd181">resp3::async_read</a>(socket, dynamic_buffer(buffer), adapter);</div>
<div class="ttc" id="agroup__any_html_structaedis_1_1resp3_1_1node"><div class="ttname"><a href="group__any.html#structaedis_1_1resp3_1_1node">aedis::resp3::node</a></div><div class="ttdoc">A node in the response tree.</div><div class="ttdef"><b>Definition:</b> <a href="node_8hpp_source.html#l00028">node.hpp:28</a></div></div>
</div><!-- fragment --><p>See more in the <a class="el" href="index.html#examples">Examples</a> section.</p>
<h1><a class="anchor" id="high-level-api"></a>
High-level API</h1>
<p>As stated earlier, the low-level API is very useful for tasks that can be performed with short lived connections. Sometimes however, the need for long-lived connections becomes compeling</p>
<ul>
<li><b>Server</b> <b>pushes:</b> Short lived connections can't deal with server pushes, that means no <a href="https://redis.io/topics/client-side-caching">client side caching</a>, <a href="https://redis.io/topics/notifications">notifications</a> and <a href="https://redis.io/topics/pubsub">pubsub</a>. </li>
<li><b>Performance:</b> Keep opening and closing connections impact performance serverely. </li>
<li><b>Pipeline:</b> Code such as shown in <a class="el" href="index.html#low-level-api">Low-level API</a> don't support pipelines well since it can only send a fixed number of commands at time. It misses important optimization opportunities (<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>).</li>
</ul>
<p>A serious implementation that supports the points listed above is far from trivial and involves many complex asynchronous operations</p>
<ul>
<li><code>async_resolve:</code> Resolve a hostname. </li>
<li><code>async_connect:</code> Connect to Redis. </li>
<li><code>async_read:</code> Performed in a loop as long as the connection lives. </li>
<li><code>async_write:</code> Performed everytime a new message is added. </li>
<li><code>async_wait:</code> To timout all operations above if the server becomes unresponsive.</li>
</ul>
<p>Notice that many of the operations above will run concurrently with each other and, in addition to that</p>
<ul>
<li><code>async_write</code> operations require management of the message queue to prevent concurrent writes. </li>
<li>Healthy checks must be sent periodically by the client to detect a dead or unresponsive server. </li>
<li>Recovery after a disconnection to avoid loosing enqueued commands.</li>
</ul>
<p>Expecting users to implement these points themselves is unrealistic and could result in code that performs poorly and can't handle errors properly. To avoid all of that, Aedis provides its own implementation. The general form of a program that uses the high-level API looks like this</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   net::io_context ioc;</div>
<div class="line"> </div>
<div class="line">   <a class="code" href="classaedis_1_1generic_1_1client.html">client_type</a> db(ioc.get_executor());</div>
<div class="line">   <span class="keyword">auto</span> recv = std::make_shared&lt;receiver&gt;(db);</div>
<div class="line">   db.set_receiver(recv);</div>
<div class="line"> </div>
<div class="line">   db.async_run(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>, [](<span class="keyword">auto</span> ec){ ... });</div>
<div class="line"> </div>
<div class="line">   ioc.run();</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1generic_1_1client_html"><div class="ttname"><a href="classaedis_1_1generic_1_1client.html">aedis::generic::client</a></div><div class="ttdoc">A high level Redis client.</div><div class="ttdef"><b>Definition:</b> <a href="client_8hpp_source.html#l00037">client.hpp:37</a></div></div>
</div><!-- fragment --><p>Users are concerned only with the implementation of the receiver. For example</p>
<div class="fragment"><div class="line"><span class="comment">// Callbacks.</span></div>
<div class="line"><span class="keyword">struct </span>receiver {</div>
<div class="line">   <span class="keywordtype">void</span> on_resp3(<a class="code" href="group__any.html#ga9661fea349313723a8ec955975184c0c">command</a> cmd, node&lt;string_view&gt; <span class="keyword">const</span>&amp; nd, error_code&amp; ec) { ...  }</div>
<div class="line">   <span class="keywordtype">void</span> on_read(<a class="code" href="group__any.html#ga9661fea349313723a8ec955975184c0c">command</a> cmd, std::size_t) { ...  }</div>
<div class="line">   <span class="keywordtype">void</span> on_push(std::size_t n) { }</div>
<div class="line">   <span class="keywordtype">void</span> on_write(std::size_t n) { ... }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__any_html_ga9661fea349313723a8ec955975184c0c"><div class="ttname"><a href="group__any.html#ga9661fea349313723a8ec955975184c0c">aedis::redis::command</a></div><div class="ttdeci">command</div><div class="ttdoc">Redis commands.</div><div class="ttdef"><b>Definition:</b> <a href="redis_2command_8hpp_source.html#l00025">command.hpp:25</a></div></div>
</div><!-- fragment --><p>The functions in the receiver above are callbacks that will be called when events arrives</p>
<ul>
<li><code>on_resp3:</code> Called when a new chunk of resp3 data is parsed. </li>
<li><code>on_read:</code> Called after the response to a command has been successfully read. </li>
<li><code>on_push:</code> Called when a server push is received. </li>
<li><code>on_write:</code> Called after a request has been successfully written to the stream.</li>
</ul>
<p>The callbacks above are never called on errors, instead the <code>async_run</code> function returns. Reconnection is also supported, for example</p>
<div class="fragment"><div class="line">net::awaitable&lt;void&gt; run(std::shared_ptr&lt;client_type&gt; db)</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">auto</span> ex = co_await net::this_coro::executor;</div>
<div class="line"> </div>
<div class="line">   boost::asio::steady_timer timer{ex};</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (error_code ec;;) {</div>
<div class="line">      co_await db-&gt;async_run(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>, redirect_error(use_awaitable, ec));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Log the error.</span></div>
<div class="line">      std::clog &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Wait two seconds and try again.</span></div>
<div class="line">      timer.expires_after(std::chrono::seconds{2});</div>
<div class="line">      co_await timer.async_wait(redirect_error(use_awaitable, ec));</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>when reconnecting the client will recover requests that haven't been sent to Redis yet.</p>
<h2><a class="anchor" id="high-level-sending-cmds"></a>
Sending commands</h2>
<p>The db object from the example above can be passed around to other objects so that commands can be sent from everywhere in the app. Sending commands is also similar to what has been discussed before</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(client&lt;net::ip::tcp::socket&gt;&amp; db)</div>
<div class="line">{</div>
<div class="line">   db.send(command::ping, <span class="stringliteral">&quot;O rato roeu a roupa do rei de Roma&quot;</span>);</div>
<div class="line">   db.send(command::incr, <span class="stringliteral">&quot;counter&quot;</span>);</div>
<div class="line">   db.send(command::set, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;Três pratos de trigo para três tigres&quot;</span>);</div>
<div class="line">   db.send(command::get, <span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>send</code> functions in this case will add commands to the output queue and send them only if there is no pending response. This is so because RESP3 is a request/response protocol, which means clients must wait for responses before sending the next request.</p>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<p>To better fix what has been said above, users should have a look at some simple examples.</p>
<p><b>Low</b> <b>level</b> <b>API</b> (sync)</p>
<ul>
<li><a class="el" href="intro__sync_8cpp_source.html">intro_sync.cpp</a>: Synchronous API usage example. </li>
<li><a class="el" href="serialization__sync_8cpp_source.html">serialization_sync.cpp</a>: Shows how serialize your own types.</li>
</ul>
<p><b>Low</b> <b>level</b> <b>API</b> (async-coroutine)</p>
<ul>
<li><a class="el" href="subscriber_8cpp_source.html">subscriber.cpp</a>: Shows how channel subscription works at the low level. </li>
<li><a class="el" href="transaction_8cpp_source.html">transaction.cpp</a>: Shows how to read the response to transactions. </li>
<li><a class="el" href="custom__adapter_8cpp_source.html">custom_adapter.cpp</a>: Shows how to write a response adapter that prints to the screen, see <a class="el" href="index.html#low-level-adapters">Adapters</a>.</li>
</ul>
<p><b>High</b> <b>level</b> <b>API</b> (async only)</p>
<ul>
<li><a class="el" href="intro__high__level_8cpp_source.html">intro_high_level.cpp</a>: High-level API usage example. </li>
<li><a class="el" href="aggregates__high__level_8cpp_source.html">aggregates_high_level.cpp</a>: Shows how receive RESP3 aggregate data types in a general way or in STL containers. </li>
<li><a class="el" href="subscriber__high__level_8cpp_source.html">subscriber_high_level.cpp</a>: Shows how channel <a href="https://redis.io/topics/pubsub">subscription</a> works at a high-level.</li>
</ul>
<p><b>Asynchronous</b> <b>Servers</b> (high-level API)</p>
<ul>
<li><a class="el" href="echo__server_8cpp_source.html">echo_server.cpp</a>: Shows the basic principles behind asynchronous communication with a database in an asynchronous server. </li>
<li><a class="el" href="chat__room_8cpp_source.html">chat_room.cpp</a>: Shows how to build a scalable chat room.</li>
</ul>
<h1><a class="anchor" id="using-aedis"></a>
Using Aedis</h1>
<p>To install and use Aedis you will need</p>
<ul>
<li>Boost 1.78 or greater.</li>
<li>Unix Shell and Make.</li>
<li>C++14. Some examples require C++20 with coroutine support.</li>
<li>Redis server.</li>
</ul>
<p>Some examples will also require interaction with</p>
<ul>
<li>redis-cli: Used in one example.</li>
<li>Redis Sentinel Server: used in some examples.</li>
</ul>
<p>Aedis has been tested with the following compilers</p>
<ul>
<li>Tested with gcc: 7.5.0, 8.4.0, 9.3.0, 10.3.0.</li>
<li>Tested with clang: 11.0.0, 10.0.0, 9.0.1, 8.0.1, 7.0.1.</li>
</ul>
<h2><a class="anchor" id="Installation"></a>
Installation</h2>
<p>The first thing to do is to download and unpack Aedis</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Download the latest release on github</span></div>
<div class="line">$ wget https:<span class="comment">//github.com/mzimbres/aedis/releases</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Uncompress the tarball and cd into the dir</span></div>
<div class="line"><span class="preprocessor">$ tar -xzvf aedis-version.tar.gz</span></div>
</div><!-- fragment --><p>If you can't use <code>configure</code> and <code>make</code> (e.g. Windows users) you can already add the directory where you unpacked Aedis to the include directories in your project, otherwise run</p>
<div class="fragment"><div class="line"><span class="preprocessor"># See configure --help for all options.</span></div>
<div class="line">$ ./configure --prefix=/opt/aedis-version --with-boost=/opt/boost_1_78_0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Install Aedis in the path specified in --prefix</span></div>
<div class="line"><span class="preprocessor">$ sudo make install</span></div>
</div><!-- fragment --><p>and include the following header</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;aedis/src.hpp&gt;</span></div>
</div><!-- fragment --><p>in exactly one source file in your applications. At this point you can start using Aedis. To build the examples and run the tests run</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Build aedis examples.</span></div>
<div class="line">$ make examples</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Test aedis in your machine.</span></div>
<div class="line"><span class="preprocessor">$ make check</span></div>
</div><!-- fragment --><h2><a class="anchor" id="Developers"></a>
Developers</h2>
<p>To generate the build system run</p>
<div class="fragment"><div class="line">$ autoreconf -i</div>
</div><!-- fragment --><p>After that you will have a configure script that you can run as explained above, for example, to use a compiler other that the system compiler run</p>
<div class="fragment"><div class="line">$ CC=/opt/gcc-10.2.0/bin/gcc-10.2.0 CXX=/opt/gcc-10.2.0/bin/g++-10.2.0 CXXFLAGS=<span class="stringliteral">&quot;-g -Wall -Werror&quot;</span>  ./configure ...</div>
<div class="line">$ make distcheck</div>
</div><!-- fragment --><h1><a class="anchor" id="why-aedis"></a>
Why Aedis</h1>
<p>At the time of this writing there are seventeen Redis clients listed in the <a href="https://redis.io/docs/clients/#cpp">official</a> list. With so many clients available it is not unlikely that users are asking themselves why yet another one. In this section I will try to compare Aedis to the most popular clients and why we need Aedis. Notice however that this is ongoing work as comparing client objectively is difficult and time consuming.</p>
<p>The most popular client at the moment of this writing ranked by github stars is</p>
<ul>
<li><a href="https://github.com/sewenew/redis-plus-plus">https://github.com/sewenew/redis-plus-plus</a></li>
</ul>
<p>Before we start it is worth mentioning some of the things it does not support</p>
<ul>
<li>RESP3. Without RESP3 is impossible to support some important Redis features like client side caching, among other things. </li>
<li>The Asio asynchronous model. </li>
<li>Serialization of user data types that avoids temporaries. </li>
<li>Error handling with error-code and exception overloads. </li>
<li>Healthy checks. </li>
<li>Fine control over memory allocation by means of allocators.</li>
</ul>
<p>The remaining points will be addressed individually.</p>
<h2><a class="anchor" id="redis-plus-plus"></a>
redis-plus-plus</h2>
<p>Let us first have a look at what sending a command a pipeline and a transaction look like</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> redis = Redis(<span class="stringliteral">&quot;tcp://127.0.0.1:6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send commands</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>); <span class="comment">// val is of type OptionalString.</span></div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending pipelines</span></div>
<div class="line"><span class="keyword">auto</span> pipe = redis.pipeline();</div>
<div class="line"><span class="keyword">auto</span> pipe_replies = pipe.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line">                        .get(<span class="stringliteral">&quot;key&quot;</span>)</div>
<div class="line">                        .rename(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;new-key&quot;</span>)</div>
<div class="line">                        .rpush(<span class="stringliteral">&quot;list&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>})</div>
<div class="line">                        .<a class="code" href="group__any.html#gga9661fea349313723a8ec955975184c0ca20b36afdb6e49e5c7780e5bea170baaa">lrange</a>(<span class="stringliteral">&quot;list&quot;</span>, 0, -1)</div>
<div class="line">                        .exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse reply with reply type and index.</span></div>
<div class="line"><span class="keyword">auto</span> set_cmd_result = pipe_replies.get&lt;<span class="keywordtype">bool</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending a transaction</span></div>
<div class="line"><span class="keyword">auto</span> tx = redis.transaction();</div>
<div class="line"><span class="keyword">auto</span> tx_replies = tx.incr(<span class="stringliteral">&quot;num0&quot;</span>)</div>
<div class="line">                    .incr(<span class="stringliteral">&quot;num1&quot;</span>)</div>
<div class="line">                    .mget({<span class="stringliteral">&quot;num0&quot;</span>, <span class="stringliteral">&quot;num1&quot;</span>})</div>
<div class="line">                    .<a class="code" href="group__any.html#gga9661fea349313723a8ec955975184c0ca52fb3679b07eb74d90784e612ca5cb30">exec</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> incr_result0 = tx_replies.get&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="agroup__any_html_gga9661fea349313723a8ec955975184c0ca20b36afdb6e49e5c7780e5bea170baaa"><div class="ttname"><a href="group__any.html#gga9661fea349313723a8ec955975184c0ca20b36afdb6e49e5c7780e5bea170baaa">aedis::redis::command::lrange</a></div><div class="ttdeci">@ lrange</div><div class="ttdoc">https://redis.io/commands/lrange</div></div>
<div class="ttc" id="agroup__any_html_gga9661fea349313723a8ec955975184c0ca52fb3679b07eb74d90784e612ca5cb30"><div class="ttname"><a href="group__any.html#gga9661fea349313723a8ec955975184c0ca52fb3679b07eb74d90784e612ca5cb30">aedis::redis::command::exec</a></div><div class="ttdeci">@ exec</div><div class="ttdoc">https://redis.io/commands/exec</div></div>
</div><!-- fragment --><p>Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. </li>
<li>Having to manually finish the pipeline with <code></code>.exec() is a major source of headache. This is not required by the protocol itself but results from the abstraction used. </li>
<li>Any Api that sends individual commands has a very restricted scope of usability and should be avoided in anything that needs minimum performance guarantees. </li>
<li>The API imposes exceptions on users, no error-code overload is provided. </li>
<li>No control over dynamic allocations. </li>
<li>No way to reuse the buffer for new calls to e.g. <code>redis.get</code> in order to avoid further dynamic memory allocations. </li>
<li>Error handling of resolve and connection no clear.</li>
</ul>
<p>According to the documentation, pipelines in redis-plus-plus have the following characteristics</p>
<blockquote class="doxtable">
<p>NOTE: By default, creating a Pipeline object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>This is clearly a downside of the API as pipelines should be the default way of communicating and not an exception, paying such a high price for each pipeline imposes a severe cost in performance. Transactions also suffer from the very same problem</p>
<blockquote class="doxtable">
<p>NOTE: Creating a Transaction object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>In Aedis there is no difference between sending one command, a pipeline or a transaction because creating the request is decoupled from the IO objects, for example</p>
<div class="fragment"><div class="line">std::string request;</div>
<div class="line"><span class="keyword">auto</span> sr = <a class="code" href="group__any.html#ga4142e05fc5f5241f8c076882443e6fd1">make_serializer</a>(request);</div>
<div class="line">sr.push(command::hello, 3);</div>
<div class="line">sr.push(command::multi);</div>
<div class="line">sr.push(command::ping, <span class="stringliteral">&quot;Some message.&quot;</span>);</div>
<div class="line">sr.push(command::set, <span class="stringliteral">&quot;low-level-key&quot;</span>, <span class="stringliteral">&quot;some content&quot;</span>, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line">sr.push(command::exec);</div>
<div class="line">sr.push(command::ping, <span class="stringliteral">&quot;Another message.&quot;</span>);</div>
<div class="line">net::write(socket, net::buffer(request));</div>
</div><!-- fragment --><p>The request created above will be sent to Redis in a single pipeline and imposes no restriction on what it contains e.g. the number of commands, transactions etc. The problems mentioned above simply do not exist in Aedis. The way responses are read is also more flexible</p>
<div class="fragment"><div class="line">std::string buffer;</div>
<div class="line"><span class="keyword">auto</span> dbuffer = net::dynamic_buffer(buffer);</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;std::string, boost::optional&lt;std::string&gt;&gt; response;</div>
<div class="line"><a class="code" href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">resp3::read</a>(socket, dbuffer); <span class="comment">// hellp</span></div>
<div class="line"><a class="code" href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">resp3::read</a>(socket, dbuffer); <span class="comment">// multi</span></div>
<div class="line"><a class="code" href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">resp3::read</a>(socket, dbuffer); <span class="comment">// ping</span></div>
<div class="line"><a class="code" href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">resp3::read</a>(socket, dbuffer); <span class="comment">// set</span></div>
<div class="line"><a class="code" href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">resp3::read</a>(socket, dbuffer, <a class="code" href="group__any.html#ga1e40a9e5ab61e7980b4be74bf0d4943d">adapt</a>(response));</div>
<div class="line"><a class="code" href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">resp3::read</a>(socket, dbuffer); <span class="comment">// quit</span></div>
<div class="ttc" id="agroup__any_html_gae85832036f8ac4d606df1c24fe27a28e"><div class="ttname"><a href="group__any.html#gae85832036f8ac4d606df1c24fe27a28e">aedis::resp3::read</a></div><div class="ttdeci">std::size_t read(SyncReadStream &amp;stream, DynamicBuffer buf, ResponseAdapter adapter, boost::system::error_code &amp;ec)</div><div class="ttdoc">Reads a complete response to a command sychronously.</div><div class="ttdef"><b>Definition:</b> <a href="read_8hpp_source.html#l00058">read.hpp:58</a></div></div>
</div><!-- fragment --><ul>
<li>The response objects are passed by the caller to the read functions so that he has fine control over memory allocations and object lifetime. </li>
<li>The user can either use error-code or exceptions. </li>
<li>Each response can be read individually in the response object avoiding temporaries. </li>
<li>It is possible to ignore responses.</li>
</ul>
<p>This was the blocking API, now let us compare the async interface</p>
<blockquote class="doxtable">
<p>redis-plus-plus also supports async interface, however, async support for Transaction and Subscriber is still on the way.</p>
<p>The async interface depends on third-party event library, and so far, only libuv is supported. </p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_redis = AsyncRedis(opts, pool_opts);</div>
<div class="line"> </div>
<div class="line">Future&lt;string&gt; ping_res = async_redis.ping();</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; ping_res.get() &lt;&lt; endl;</div>
</div><!-- fragment --><p>As the reader can see, the async interface is based on futures which is also known to have a bad performance. The biggest problem however with this async design is that it makes it impossible to write asynchronous programs correctly since it starts an async operation on every command sent instead of enqueueing a message and triggering a write. It is also not clear how are pipelines realised with the design (if at all).</p>
<p>In Aedis the send function looks like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Ts&gt;</div>
<div class="line"><span class="keywordtype">void</span> client::send(Command cmd, Ts <span class="keyword">const</span>&amp;... args);</div>
</div><!-- fragment --><p>and the response is delivered through a callback.</p>
<h1><a class="anchor" id="Acknowledgement"></a>
Acknowledgement</h1>
<p>Some people that were helpful in the development of Aedis</p>
<ul>
<li>Richard Hodges (<a href="https://github.com/madmongo1">madmongo1</a>): For answering pretty much every question I had about Asio and the design of asynchronous programs. </li>
<li>Vinícius dos Santos Oliveira (<a href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful discussion about how Aedis consumes buffers in the read operation (among other things).</li>
</ul>
<h1><a class="anchor" id="Reference"></a>
Reference</h1>
<p>See <a class="el" href="group__any.html">Reference</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
Author: Marcelo Zimbres Silva.
</address>
</body>
</html>
