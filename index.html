<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aedis: Aedis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Aedis<span id="projectnumber">&#160;1.4.1</span>
   </div>
   <div id="projectbrief">A redis client library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Aedis </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> Aedis is a <a href="https://redis.io/">Redis</a> client library built on top of <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a> that implements the latest version of the Redis communication protocol <a href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>. It makes communication with a Redis server easy by hiding low-level code away from the user, which, in the majority of the cases will be concerned with only three library entities</p>
<ul>
<li><code>aedis::connection</code>: A connection to the Redis server with high-level functions to execute Redis commands, receive server pushes and support for automatic command <a href="https://redis.io/docs/manual/pipelining/">pipelines</a>.</li>
<li><code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code>: A container of Redis commands that supports STL containers and user defined data types.</li>
<li><code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code>: A function that adapts data structures to receive responses.</li>
</ul>
<p >In the next sections we will cover all those points in detail with examples. The requirements for using Aedis are</p>
<ul>
<li>Boost 1.80 or greater.</li>
<li>C++17 minimum.</li>
<li>Redis 6 or higher (must support RESP3).</li>
<li>Gcc (10, 11, 12), Clang (11, 13, 14) and Visual Studio (16 2019, 17 2022).</li>
<li>Have basic-level knowledge about Redis and understand Asio and its asynchronous model.</li>
</ul>
<p >Readers that are not familiar with Redis can learn more about it on <a href="https://redis.io/docs/">https://redis.io/docs/</a>, in essence</p>
<blockquote class="doxtable">
<p >&zwj;Redis is an open source (BSD licensed), in-memory data structure store used as a database, cache, message broker, and streaming engine. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster. </p>
</blockquote>
<p><a class="anchor" id="connection"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Connection</h1>
<p >Let us start with a simple application that uses a short-lived connection to read Redis <a href="https://redis.io/docs/data-types/hashes/">hashes</a> in a <code>std::map</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> co_main() -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_class" href="classaedis_1_1basic__connection.html">connection</a> conn{<span class="keyword">co_await</span> net::this_coro::executor};</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// From examples/common.hpp to avoid vebosity</span></div>
<div class="line">   <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// A request can contain multiple commands.</span></div>
<div class="line">   <a class="code hl_class" href="classaedis_1_1resp3_1_1request.html">resp3::request</a> req;</div>
<div class="line">   req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">   req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;hset-key&quot;</span>);</div>
<div class="line">   req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The tuple elements will store the responses to each individual</span></div>
<div class="line">   <span class="comment">// command. The responses to HELLO and QUIT are being ignored for</span></div>
<div class="line">   <span class="comment">// simplicity.</span></div>
<div class="line">   std::tuple&lt;ignore, std::map&lt;std::string, std::string&gt;, <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">ignore</a>&gt; resp;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Executes the request. See below why we are using operator ||.</span></div>
<div class="line">   <span class="keyword">co_await</span> (conn.async_run() || conn.async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp)));</div>
<div class="line">   <span class="comment">// Use the map from std::get&lt;1&gt;(resp) ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1basic__connection_html"><div class="ttname"><a href="classaedis_1_1basic__connection.html">aedis::basic_connection</a></div><div class="ttdoc">A connection to the Redis server.</div><div class="ttdef"><b>Definition:</b> <a href="connection_8hpp_source.html#l00029">connection.hpp:32</a></div></div>
<div class="ttc" id="aclassaedis_1_1resp3_1_1request_html"><div class="ttname"><a href="classaedis_1_1resp3_1_1request.html">aedis::resp3::request</a></div><div class="ttdoc">Creates Redis requests.</div><div class="ttdef"><b>Definition:</b> <a href="request_8hpp_source.html#l00169">request.hpp:169</a></div></div>
<div class="ttc" id="aclassaedis_1_1resp3_1_1request_html_a1a7b7e58ed214bcd962d20b65ed35eca"><div class="ttname"><a href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">aedis::resp3::request::push</a></div><div class="ttdeci">void push(std::string_view cmd, Ts const &amp;... args)</div><div class="ttdoc">Appends a new command to the end of the request.</div><div class="ttdef"><b>Definition:</b> <a href="request_8hpp_source.html#l00261">request.hpp:261</a></div></div>
<div class="ttc" id="agroup__high-level-api_html_ga0d619e51ab37f7854e7218a061900820"><div class="ttname"><a href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a></div><div class="ttdeci">adapter::detail::ignore ignore</div><div class="ttdoc">Tag used to ignore responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00036">adapt.hpp:36</a></div></div>
<div class="ttc" id="agroup__high-level-api_html_gac56bb1a8df93445853a4b9dae2d97b6e"><div class="ttname"><a href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">aedis::adapt</a></div><div class="ttdeci">auto adapt(std::size_t max_read_size=(std::numeric_limits&lt; std::size_t &gt;::max)()) noexcept</div><div class="ttdoc">Creates an adapter that ignores responses.</div><div class="ttdef"><b>Definition:</b> <a href="adapt_8hpp_source.html#l00199">adapt.hpp:199</a></div></div>
</div><!-- fragment --><p >The example above uses the Asio awaitable <code>operator ||</code> to compose <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> and <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> in an operation we can <code>co_await</code> on. It also provides cancelation of one of the operations when the other completes. The role played by these functions are</p>
<ul>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code>: Execute commands by queuing the request for writing and wait for the response sent back by Redis. Can be called from multiple places in your code concurrently.</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code>: Coordinate low-level read and write operations. More specifically, it will hand IO control to <code>async_exec</code> when a response arrives and to <code>async_receive</code> when a server-push is received. It is also responsible for triggering writes of pending requests.</li>
</ul>
<p >The example above is also available in other programming styles for comparison</p>
<ul>
<li><a class="el" href="cpp20__intro__awaitable__ops_8cpp_source.html">cpp20_intro_awaitable_ops.cpp</a>: The version shown above.</li>
<li><a class="el" href="cpp20__intro_8cpp_source.html">cpp20_intro.cpp</a>: Does not use awaitable operators.</li>
<li><a class="el" href="cpp20__intro__tls_8cpp_source.html">cpp20_intro_tls.cpp</a>: Communicates over TLS.</li>
<li><a class="el" href="cpp17__intro_8cpp_source.html">cpp17_intro.cpp</a>: Uses callbacks and requires C++17.</li>
<li><a class="el" href="cpp17__intro__sync_8cpp_source.html">cpp17_intro_sync.cpp</a>: Runs <code>async_run</code> in a separate thread and performs synchronous calls to <code>async_exec</code>.</li>
</ul>
<p >For performance reasons we will usually want to perform multiple requests with the same connection. We can do this in the example above by letting <code>async_run</code> run detached in a separate coroutine, for example (see <a class="el" href="cpp20__intro_8cpp_source.html">cpp20_intro.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> run(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_run();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> hello(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_class" href="classaedis_1_1resp3_1_1request.html">resp3::request</a> req;</div>
<div class="line">   req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_exec(req);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> ping(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_class" href="classaedis_1_1resp3_1_1request.html">resp3::request</a> req;</div>
<div class="line">   req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;PING&quot;</span>, <span class="stringliteral">&quot;Hello world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   std::tuple&lt;std::string&gt; resp;</div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line">   <span class="comment">// Use the response ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> quit(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_class" href="classaedis_1_1resp3_1_1request.html">resp3::request</a> req;</div>
<div class="line">   req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_exec(req);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> co_main() -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">auto</span> ex = <span class="keyword">co_await</span> net::this_coro::executor;</div>
<div class="line">   <span class="keyword">auto</span> conn = std::make_shared&lt;connection&gt;(ex);</div>
<div class="line">   net::co_spawn(ex, <a class="code hl_enumvalue" href="group__high-level-api.html#ggadcfe42e0996c05d14fe5f8bacce384bcaa53108f7543b75adbb34afc035d4cdf6">run</a>(conn), net::detached);</div>
<div class="line">   <span class="keyword">co_await</span> hello(conn);</div>
<div class="line">   <span class="keyword">co_await</span> ping(conn);</div>
<div class="line">   <span class="keyword">co_await</span> quit(conn);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// conn can be passed around to other coroutines that need to</span></div>
<div class="line">   <span class="comment">// communicate with Redis.  For example, sessions in a HTTP and</span></div>
<div class="line">   <span class="comment">// Websocket server.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__high-level-api_html_ggadcfe42e0996c05d14fe5f8bacce384bcaa53108f7543b75adbb34afc035d4cdf6"><div class="ttname"><a href="group__high-level-api.html#ggadcfe42e0996c05d14fe5f8bacce384bcaa53108f7543b75adbb34afc035d4cdf6">aedis::operation::run</a></div><div class="ttdeci">@ run</div><div class="ttdoc">Refers to connection::async_run operations.</div></div>
</div><!-- fragment --><p >With this separation, it is now easy to incorporate other long-running operations in our application, for example, the run coroutine below adds signal handling and a healthy checker (see <a class="el" href="cpp20__echo__server_8cpp_source.html">cpp20_echo_server.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> run(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   signal_set sig{<span class="keyword">co_await</span> net::this_coro::executor, SIGINT, SIGTERM};</div>
<div class="line">   <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line">   <span class="keyword">co_await</span> (conn-&gt;async_run() || sig.async_wait() || healthy_checker(conn));</div>
<div class="line">}</div>
</div><!-- fragment --><p >The definition of the <code>healthy_checker</code> used above can be found in <a class="el" href="common_8cpp_source.html">common.cpp</a>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Server pushes</h2>
<p >Redis servers can also send a variety of pushes to the client, some of them are</p>
<ul>
<li><a href="https://redis.io/docs/manual/pubsub/">Pubsub</a></li>
<li><a href="https://redis.io/docs/manual/keyspace-notifications/">Keyspace notification</a></li>
<li><a href="https://redis.io/docs/manual/client-side-caching/">Client-side caching</a></li>
</ul>
<p >The connection class supports server pushes by means of the <code><a class="el" href="classaedis_1_1basic__connection.html#ac865f2f3339856b4bbe233e353a3a6b3" title="Receives server side pushes asynchronously.">aedis::connection::async_receive</a></code> function, the coroutine shows how to used it</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> receiver(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">using </span>resp_type = std::vector&lt;resp3::node&lt;std::string&gt;&gt;;</div>
<div class="line">   <span class="keywordflow">for</span> (resp_type resp;;) {</div>
<div class="line">      <span class="keyword">co_await</span> conn-&gt;async_receive(<a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
<div class="line">      <span class="comment">// Use resp and clear the response for a new push.</span></div>
<div class="line">      resp.clear();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p >The <code>receiver</code> defined above can be run detached or incorporated in the <code>run</code> function as we did for the <code>healthy_checker</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> run(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   signal_set sig{<span class="keyword">co_await</span> net::this_coro::executor, SIGINT, SIGTERM};</div>
<div class="line">   <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line">   <span class="keyword">co_await</span> (conn-&gt;async_run() || sig.async_wait() || healthy_checker(conn) || receiver(conn));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Reconnecting</h2>
<p >Adding a loop around <code>async_run</code> produces a simple way to support reconnection <em>while there are pending operations on the connection</em>, for example, to reconnect to the same address (see <a class="el" href="cpp20__subscriber_8cpp_source.html">cpp20_subscriber.cpp</a>)</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> run(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   steady_timer timer{<span class="keyword">co_await</span> net::this_coro::executor};</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (;;) {</div>
<div class="line">      <span class="keyword">co_await</span> connect(conn, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, <span class="stringliteral">&quot;6379&quot;</span>);</div>
<div class="line">      <span class="keyword">co_await</span> (conn-&gt;async_run() || healthy_checker(conn) || receiver(conn));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Prepare the stream for a new connection.</span></div>
<div class="line">      conn-&gt;reset_stream();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Waits one second before trying to reconnect.</span></div>
<div class="line">      timer.expires_after(std::chrono::seconds{1});</div>
<div class="line">      <span class="keyword">co_await</span> timer.async_wait();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p >This feature results in considerable simplification of backend code and makes it easier to write failover-safe applications. For example, a Websocket server might have a 10k sessions communicating with Redis at the time the connection is lost (or maybe killed by the server admin to force a failover). It would be concerning if each individual section were to throw exceptions and handle error. With the pattern shown above the only place that has to manage the error is the run function.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Cancellation</h2>
<p >Aedis supports both implicit and explicit cancellation of connection operations. Explicit cancellation is supported by means of the <code><a class="el" href="classaedis_1_1basic__connection.html#a6031e4ec3662db74a0ce94e0877bae12" title="Cancel operations.">aedis::connection::cancel</a></code> member function. Implicit terminal-cancellation, like those that happen when using Asio awaitable <code>operator ||</code> will be discussed with more detail below.</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_run(...) || conn.async_exec(...))</div>
</div><!-- fragment --><ul>
<li>Useful for short-lived connections that are meant to be closed after a command has been executed.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_exec(...) || time.async_wait(...))</div>
</div><!-- fragment --><ul>
<li>Provides a way to limit how long the execution of a single request should last.</li>
<li>WARNING: If the timer fires after the request has been sent but before the response has been received, the connection will be closed.</li>
<li>It is usually a better idea to have a healthy checker than adding per request timeout, see <a class="el" href="cpp20__subscriber_8cpp_source.html">cpp20_subscriber.cpp</a> for an example.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> (conn.async_exec(...) || conn.async_exec(...) || ... || conn.async_exec(...))</div>
</div><!-- fragment --><ul>
<li>This works but is unnecessary. Unless the user has set <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a253cef2ca5d60b1b319019fafb3d27b3" title="If true the request will be coalesced with other requests, see https://redis.io/topics/pipelining....">aedis::resp3::request::config::coalesce</a></code> to <code>false</code>, and he usually shouldn't, the connection will automatically merge the individual requests into a single payload.</li>
</ul>
<p ><a class="anchor" id="requests"></a> </p>
<h1><a class="anchor" id="autotoc_md5"></a>
Requests</h1>
<p >Redis requests are composed of one or more commands (in the Redis documentation they are called <a href="https://redis.io/topics/pipelining">pipelines</a>). For example</p>
<div class="fragment"><div class="line"><span class="comment">// Some example containers.</span></div>
<div class="line">std::list&lt;std::string&gt; list {...};</div>
<div class="line">std::map&lt;std::string, mystruct&gt; map { ...};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The request can contains multiple commands.</span></div>
<div class="line">request req;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with variable length of arguments.</span></div>
<div class="line">req.<a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca">push</a>(<span class="stringliteral">&quot;SET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;some value&quot;</span>, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a list.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but as an iterator range.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, std::cbegin(list), std::cend(list));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a map.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Sending a request to Redis is performed with <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">aedis::connection::async_exec</a></code> as already stated.</p>
<p ><a class="anchor" id="serialization"></a></p>
<h2><a class="anchor" id="autotoc_md6"></a>
Serialization</h2>
<p >The <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a1a7b7e58ed214bcd962d20b65ed35eca" title="Appends a new command to the end of the request.">resp3::request::push</a></code> and <code><a class="el" href="classaedis_1_1resp3_1_1request.html#acfdc2a284c938a7cba37cd4d69b006b7" title="Appends a new command to the end of the request.">resp3::request::push_range</a></code> member functions work with integer data types e.g. <code>int</code> and <code>std::string</code> out of the box. To send your own data type define a <code>to_bulk</code> function like this</p>
<div class="fragment"><div class="line"><span class="comment">// User defined type.</span></div>
<div class="line"><span class="keyword">struct </span>mystruct {...};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Serialize it in to_bulk.</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classaedis_1_1resp3_1_1request.html#a9951b16b0c2a2677852ffe2e0778a539">to_bulk</a>(std::pmr::string&amp; to, mystruct <span class="keyword">const</span>&amp; obj)</div>
<div class="line">{</div>
<div class="line">   std::string dummy = <span class="stringliteral">&quot;Dummy serializaiton string.&quot;</span>;</div>
<div class="line">   aedis::resp3::to_bulk(to, dummy);</div>
<div class="line">}</div>
<div class="ttc" id="aclassaedis_1_1resp3_1_1request_html_a9951b16b0c2a2677852ffe2e0778a539"><div class="ttname"><a href="classaedis_1_1resp3_1_1request.html#a9951b16b0c2a2677852ffe2e0778a539">aedis::resp3::request::to_bulk</a></div><div class="ttdeci">void to_bulk(Request &amp;to, std::string_view data)</div><div class="ttdoc">Adds a bulk to the request.</div><div class="ttdef"><b>Definition:</b> <a href="request_8hpp_source.html#l00046">request.hpp:46</a></div></div>
</div><!-- fragment --><p >Once <code>to_bulk</code> is defined and visible over ADL <code>mystruct</code> can be passed to the <code>request</code></p>
<div class="fragment"><div class="line">request req;</div>
<div class="line"> </div>
<div class="line">std::map&lt;std::string, mystruct&gt; map {...};</div>
<div class="line"> </div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Example <a class="el" href="cpp20__serialization_8cpp_source.html">cpp20_serialization.cpp</a> shows how store json strings in Redis.</p>
<p ><a class="anchor" id="responses"></a></p>
<h2><a class="anchor" id="autotoc_md7"></a>
Config flags</h2>
<p >The <code><a class="el" href="classaedis_1_1resp3_1_1request.html#structaedis_1_1resp3_1_1request_1_1config" title="Request configuration options.">aedis::resp3::request::config</a></code> object inside the request dictates how the <code>aedis::connection</code> should handle the request in some important situations. The reader is advised to read it carefully.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Responses</h1>
<p >Aedis uses the following strategy to support Redis responses</p>
<ul>
<li><b>Static</b>: For <code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code> whose sizes are known at compile time <code>std::tuple</code> is supported.</li>
<li><b>Dynamic</b>: Otherwise use <code>std::vector&lt;<a class="el" href="structaedis_1_1resp3_1_1node.html" title="A node in the response tree.">aedis::resp3::node</a>&lt;std::string&gt;&gt;</code>.</li>
</ul>
<p >For example, below is a request with a compile time size</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;INCR&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >To read the response to this request users can use the following tuple</p>
<div class="fragment"><div class="line">std::tuple&lt;std::string, int, std::string&gt;</div>
</div><!-- fragment --><p >The pattern might have become apparent to the reader: the tuple must have as many elements as the request has commands (exceptions below). It is also necessary that each tuple element is capable of storing the response to the command it refers to, otherwise an error will occur. To ignore responses to individual commands in the request use the tag <code>aedis::ignore</code></p>
<div class="fragment"><div class="line"><span class="comment">// Ignore the second and last responses.</span></div>
<div class="line">std::tuple&lt;std::string, aedis::ignore, std::string, aedis::ignore&gt;</div>
</div><!-- fragment --><p >The following table provides the resp3-types returned by some Redis commands</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lpush   </td><td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lrange   </td><td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set   </td><td class="markdownTableBodyNone">Simple-string, null or blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/set">https://redis.io/commands/set</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">get   </td><td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/get">https://redis.io/commands/get</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">smembers   </td><td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hgetall   </td><td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a>   </td></tr>
</table>
<p >To map these RESP3 types into a C++ data structure use the table below</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Possible C++ type   </th><th class="markdownTableHeadNone">Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple-string   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple-error   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blob-error   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><code>long long</code>, <code>int</code>, <code>std::size_t</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone"><code>double</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Null   </td><td class="markdownTableBodyNone"><code>std::optional&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::list</code>, <code>std::array</code>, <code>std::deque</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::set</code>, <code>std::unordered_set</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Push   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate   </td></tr>
</table>
<p >For example, the response to the request</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;RPUSH&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>, vec);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, map);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key4&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >can be read in the tuple below</p>
<div class="fragment"><div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// hello</span></div>
<div class="line">   int,            <span class="comment">// rpush</span></div>
<div class="line">   int,            <span class="comment">// hset</span></div>
<div class="line">   std::vector&lt;T&gt;, <span class="comment">// lrange</span></div>
<div class="line">   std::map&lt;U, V&gt;, <span class="comment">// hgetall</span></div>
<div class="line">   std::string     <span class="comment">// quit</span></div>
<div class="line">&gt; resp;</div>
</div><!-- fragment --><p >Where both are passed to <code>async_exec</code> as showed elsewhere</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >If the intention is to ignore the response to all commands altogether use <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">adapt()</a></code> without arguments instead</p>
<div class="fragment"><div class="line"><span class="comment">// Uses the ignore adapter explicitly.</span></div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Ignore adapter is also the default argument.</span></div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req);</div>
</div><!-- fragment --><p >Responses that contain nested aggregates or heterogeneous data types will be given special treatment later in <a class="el" href="index.html#the-general-case">The general case</a>. As of this writing, not all RESP3 types are used by the Redis server, which means in practice users will be concerned with a reduced subset of the RESP3 specification.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Pushes</h2>
<p >Commands that have no response like</p>
<ul>
<li><code>"SUBSCRIBE"</code></li>
<li><code>"PSUBSCRIBE"</code></li>
<li><code>"UNSUBSCRIBE"</code></li>
</ul>
<p >must be <b>NOT</b> be included in the response tuple. For example, the request below</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, <span class="stringliteral">&quot;channel&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >must be read in this tuple <code>std::tuple&lt;std::string, std::string&gt;</code>, that has size two.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Null</h2>
<p >It is not uncommon for apps to access keys that do not exist or that have already expired in the Redis server, to deal with these cases Aedis provides support for <code>std::optional</code>. To use it, wrap your type around <code>std::optional</code> like this</p>
<div class="fragment"><div class="line">std::tuple&lt;</div>
<div class="line">   std::optional&lt;A&gt;,</div>
<div class="line">   std::optional&lt;B&gt;,</div>
<div class="line">   ...</div>
<div class="line">   &gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >Everything else stays pretty much the same.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Transactions</h2>
<p >To read responses to transactions we must first observe that Redis will queue the transaction commands and send their individual responses as elements of an array, the array is itself the response to the <code>EXEC</code> command. For example, to read the response to this request</p>
<div class="fragment"><div class="line">req.push(<span class="stringliteral">&quot;MULTI&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;EXEC&quot;</span>);</div>
</div><!-- fragment --><p >use the following response type</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>exec_resp_type = </div>
<div class="line">   std::tuple&lt;</div>
<div class="line">      std::optional&lt;std::string&gt;, <span class="comment">// get</span></div>
<div class="line">      std::optional&lt;std::vector&lt;std::string&gt;&gt;, <span class="comment">// lrange</span></div>
<div class="line">      std::optional&lt;std::map&lt;std::string, std::string&gt;&gt; <span class="comment">// hgetall</span></div>
<div class="line">   &gt;;</div>
<div class="line"> </div>
<div class="line">std::tuple&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// multi</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// get</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// lrange</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga0d619e51ab37f7854e7218a061900820">aedis::ignore</a>,  <span class="comment">// hgetall</span></div>
<div class="line">   exec_resp_type, <span class="comment">// exec</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >For a complete example see <a class="el" href="cpp20__containers_8cpp_source.html">cpp20_containers.cpp</a>.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Deserialization</h2>
<p >As mentioned in the serialization section, it is common practice to serialize data before sending it to Redis e.g. as json strings. For performance and convenience reasons, we may also want to deserialize responses directly in their final data structure. Aedis supports this use case by calling a user provided <code>from_bulk</code> function while parsing the response. For example</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> from_bulk(mystruct&amp; obj, <span class="keywordtype">char</span> <span class="keyword">const</span>* p, std::size_t size, boost::system::error_code&amp; ec)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Deserializes p into obj.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >After that, you can start receiving data efficiently in the desired types e.g. <code>mystruct</code>, <code>std::map&lt;std::string, mystruct&gt;</code> etc.</p>
<p ><a class="anchor" id="the-general-case"></a></p>
<h2><a class="anchor" id="autotoc_md13"></a>
The general case</h2>
<p >There are cases where responses to Redis commands won't fit in the model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose responses don't have a fixed RESP3 type. Expecting an <code>int</code> and receiving a blob-string will result in error.</li>
<li>RESP3 aggregates that contain nested aggregates can't be read in STL containers.</li>
<li>Transactions with a dynamic number of commands can't be read in a <code>std::tuple</code>.</li>
</ul>
<p >To deal with these cases Aedis provides the <code><a class="el" href="structaedis_1_1resp3_1_1node.html" title="A node in the response tree.">aedis::resp3::node</a></code> type abstraction, that is the most general form of an element in a response, be it a simple RESP3 type or the element of an aggregate. It is defined like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;</div>
<div class="line"><span class="keyword">struct </span>node {</div>
<div class="line">   <span class="comment">// The RESP3 type of the data in this node.</span></div>
<div class="line">   <a class="code hl_enumeration" href="group__high-level-api.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">type</a> data_type;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The number of elements of an aggregate (or 1 for simple data).</span></div>
<div class="line">   std::size_t aggregate_size;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The depth of this node in the response tree.</span></div>
<div class="line">   std::size_t depth;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The actual data. For aggregate types this is always empty.</span></div>
<div class="line">   String value;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__high-level-api_html_gabdb6bdf6f96b4a7a91ed63d2324cef57"><div class="ttname"><a href="group__high-level-api.html#gabdb6bdf6f96b4a7a91ed63d2324cef57">aedis::resp3::type</a></div><div class="ttdeci">type</div><div class="ttdoc">RESP3 data types.</div><div class="ttdef"><b>Definition:</b> <a href="type_8hpp_source.html#l00021">type.hpp:22</a></div></div>
</div><!-- fragment --><p >Any response to a Redis command can be received in a <code>std::vector&lt;node&lt;std::string&gt;&gt;</code>. The vector can be seen as a pre-order view of the response tree. Using it is not different than using other types</p>
<div class="fragment"><div class="line"><span class="comment">// Receives any RESP3 simple or aggregate data type.</span></div>
<div class="line">std::vector&lt;node&lt;std::string&gt;&gt; resp;</div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, <a class="code hl_function" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e">adapt</a>(resp));</div>
</div><!-- fragment --><p >For example, suppose we want to retrieve a hash data structure from Redis with <code>HGETALL</code>, some of the options are</p>
<ul>
<li><code>std::vector&lt;node&lt;std::string&gt;</code>: Works always.</li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all elements as string.</li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if you need the data as a <code>std::map</code>.</li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing serialized data. Avoids temporaries and requires <code>from_bulk</code> for <code>U</code> and <code>V</code>.</li>
</ul>
<p >In addition to the above users can also use unordered versions of the containers. The same reasoning applies to sets e.g. <code>SMEMBERS</code> and other data structures in general.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Examples</h1>
<p >The examples below show how to use the features discussed so far</p>
<ul>
<li><a class="el" href="cpp20__intro__awaitable__ops_8cpp_source.html">cpp20_intro_awaitable_ops.cpp</a>: The version shown above.</li>
<li><a class="el" href="cpp20__intro_8cpp_source.html">cpp20_intro.cpp</a>: Does not use awaitable operators.</li>
<li><a class="el" href="cpp20__intro__tls_8cpp_source.html">cpp20_intro_tls.cpp</a>: Communicates over TLS.</li>
<li><a class="el" href="cpp20__containers_8cpp_source.html">cpp20_containers.cpp</a>: Shows how to send and receive STL containers and how to use transactions.</li>
<li><a class="el" href="cpp20__serialization_8cpp_source.html">cpp20_serialization.cpp</a>: Shows how to serialize types using Boost.Json.</li>
<li><a class="el" href="cpp20__resolve__with__sentinel_8cpp_source.html">cpp20_resolve_with_sentinel.cpp</a>: Shows how to resolve a master address using sentinels.</li>
<li><a class="el" href="cpp20__subscriber_8cpp_source.html">cpp20_subscriber.cpp</a>: Shows how to implement pubsub with reconnection re-subscription.</li>
<li><a class="el" href="cpp20__echo__server_8cpp_source.html">cpp20_echo_server.cpp</a>: A simple TCP echo server.</li>
<li><a class="el" href="cpp20__chat__room_8cpp_source.html">cpp20_chat_room.cpp</a>: A command line chat built on Redis pubsub.</li>
<li><a class="el" href="cpp20__low__level__async_8cpp_source.html">cpp20_low_level_async.cpp</a>: Sends a ping asynchronously using the low-level API.</li>
<li><a class="el" href="cpp17__low__level__sync_8cpp_source.html">cpp17_low_level_sync.cpp</a>: Sends a ping synchronously using the low-level API.</li>
<li><a class="el" href="cpp17__intro_8cpp_source.html">cpp17_intro.cpp</a>: Uses callbacks and requires C++17.</li>
<li><a class="el" href="cpp17__intro__sync_8cpp_source.html">cpp17_intro_sync.cpp</a>: Runs <code>async_run</code> in a separate thread and performs synchronous calls to <code>async_exec</code>.</li>
</ul>
<p >To avoid repetition code that is common to some examples has been grouped in <a class="el" href="common_8hpp_source.html">common.hpp</a>. The main function used in some async examples has been factored out in the <a class="el" href="main_8cpp_source.html">main.cpp</a> file.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Echo server benchmark</h1>
<p >This document benchmarks the performance of TCP echo servers I implemented in different languages using different Redis clients. The main motivations for choosing an echo server are</p>
<ul>
<li>Simple to implement and does not require expertise level in most languages.</li>
<li>I/O bound: Echo servers have very low CPU consumption in general and therefore are excelent to measure how a program handles concurrent requests.</li>
<li>It simulates very well a typical backend in regard to concurrency.</li>
</ul>
<p >I also imposed some constraints on the implementations</p>
<ul>
<li>It should be simple enough and not require writing too much code.</li>
<li>Favor the use standard idioms and avoid optimizations that require expert level.</li>
<li>Avoid the use of complex things like connection and thread pool.</li>
</ul>
<p >To reproduce these results run one of the echo-server programs in one terminal and the <a href="https://github.com/mzimbres/aedis/blob/42880e788bec6020dd018194075a211ad9f339e8/benchmarks/cpp/asio/echo_server_client.cpp">echo-server-client</a> in another.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Without Redis</h2>
<p >First I tested a pure TCP echo server, i.e. one that sends the messages directly to the client without interacting with Redis. The result can be seen below</p>
<p ><img src="https://mzimbres.github.io/aedis/tcp-echo-direct.png" alt="" class="inline"/></p>
<p >The tests were performed with a 1000 concurrent TCP connections on the localhost where latency is 0.07ms on average on my machine. On higher latency networks the difference among libraries is expected to decrease.</p>
<ul>
<li>I expected Libuv to have similar performance to Asio and Tokio.</li>
<li>I did expect nodejs to come a little behind given it is is javascript code. Otherwise I did expect it to have similar performance to libuv since it is the framework behind it.</li>
<li>Go did surprise me: faster than nodejs and libuv!</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/cpp/asio/echo_server_direct.cpp">Asio</a>: A variation of <a href="https://github.com/chriskohlhoff/asio/blob/4915cfd8a1653c157a1480162ae5601318553eb8/asio/src/examples/cpp20/coroutines/echo_server.cpp">this</a> Asio example.</li>
<li><a href="https://github.com/mzimbres/aedis/tree/835a1decf477b09317f391eddd0727213cdbe12b/benchmarks/c/libuv">Libuv</a>: Taken from <a href="https://github.com/libuv/libuv/blob/06948c6ee502862524f233af4e2c3e4ca876f5f6/docs/code/tcp-echo-server/main.c">here</a> Libuv example .</li>
<li><a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/rust/echo_server_direct">Tokio</a>: Taken from <a href="https://docs.rs/tokio/latest/tokio/">here</a>.</li>
<li><a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_direct">Nodejs</a></li>
<li><a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_direct.go">Go</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
With Redis</h2>
<p >This is similar to the echo server described above but messages are echoed by Redis and not by the echo-server itself, which acts as a proxy between the client and the Redis server. The results can be seen below</p>
<p ><img src="https://mzimbres.github.io/aedis/tcp-echo-over-redis.png" alt="" class="inline"/></p>
<p >The tests were performed on a network where latency is 35ms on average, otherwise it uses the same number of TCP connections as the previous example.</p>
<p >As the reader can see, the Libuv and the Rust test are not depicted in the graph, the reasons are</p>
<ul>
<li><a href="https://github.com/redis-rs/redis-rs">redis-rs</a>: This client comes so far behind that it can't even be represented together with the other benchmarks without making them look insignificant. I don't know for sure why it is so slow, I suppose it has something to do with its lack of automatic <a href="https://redis.io/docs/manual/pipelining/">pipelining</a> support. In fact, the more TCP connections I lauch the worse its performance gets.</li>
<li>Libuv: I left it out because it would require me writing to much c code. More specifically, I would have to use hiredis and implement support for pipelines manually.</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/mzimbres/aedis">Aedis</a>: <a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/examples/echo_server.cpp">code</a></li>
<li><a href="https://github.com/redis/node-redis">node-redis</a>: <a href="https://github.com/mzimbres/aedis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_over_redis">code</a></li>
<li><a href="https://github.com/go-redis/redis">go-redis</a>: <a href="https://github.com/mzimbres/aedis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_over_redis.go">code</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Conclusion</h2>
<p >Redis clients have to support automatic pipelining to have competitive performance. For updates to this document follow <a href="https://github.com/mzimbres/aedis">https://github.com/mzimbres/aedis</a>.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Comparison</h1>
<p >The main reason for why I started writing Aedis was to have a client compatible with the Asio asynchronous model. As I made progresses I could also address what I considered weaknesses in other libraries. Due to time constraints I won't be able to give a detailed comparison with each client listed in the <a href="https://redis.io/docs/clients/#cpp">official</a> list, instead I will focus on the most popular C++ client on github in number of stars, namely</p>
<ul>
<li><a href="https://github.com/sewenew/redis-plus-plus">https://github.com/sewenew/redis-plus-plus</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
Aedis vs Redis-plus-plus</h2>
<p >Before we start it is important to mention some of the things redis-plus-plus does not support</p>
<ul>
<li>The latest version of the communication protocol RESP3. Without that it is impossible to support some important Redis features like client side caching, among other things.</li>
<li>Coroutines.</li>
<li>Reading responses directly in user data structures to avoid creating temporaries.</li>
<li>Error handling with support for error-code.</li>
<li>Cancellation.</li>
</ul>
<p >The remaining points will be addressed individually. Let us first have a look at what sending a command a pipeline and a transaction look like</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> redis = Redis(<span class="stringliteral">&quot;tcp://127.0.0.1:6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send commands</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>); <span class="comment">// val is of type OptionalString.</span></div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending pipelines</span></div>
<div class="line"><span class="keyword">auto</span> pipe = redis.pipeline();</div>
<div class="line"><span class="keyword">auto</span> pipe_replies = pipe.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line">                        .get(<span class="stringliteral">&quot;key&quot;</span>)</div>
<div class="line">                        .rename(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;new-key&quot;</span>)</div>
<div class="line">                        .rpush(<span class="stringliteral">&quot;list&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>})</div>
<div class="line">                        .lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1)</div>
<div class="line">                        .exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse reply with reply type and index.</span></div>
<div class="line"><span class="keyword">auto</span> set_cmd_result = pipe_replies.get&lt;<span class="keywordtype">bool</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending a transaction</span></div>
<div class="line"><span class="keyword">auto</span> tx = redis.transaction();</div>
<div class="line"><span class="keyword">auto</span> tx_replies = tx.incr(<span class="stringliteral">&quot;num0&quot;</span>)</div>
<div class="line">                    .incr(<span class="stringliteral">&quot;num1&quot;</span>)</div>
<div class="line">                    .mget({<span class="stringliteral">&quot;num0&quot;</span>, <span class="stringliteral">&quot;num1&quot;</span>})</div>
<div class="line">                    .exec();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> incr_result0 = tx_replies.get&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p >Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. This makes auto-pipelining impossible.</li>
<li>Any Api that sends individual commands has a very restricted scope of usability and should be avoided for performance reasons.</li>
<li>The API imposes exceptions on users, no error-code overload is provided.</li>
<li>No way to reuse the buffer for new calls to e.g. redis.get in order to avoid further dynamic memory allocations.</li>
<li>Error handling of resolve and connection not clear.</li>
</ul>
<p >According to the documentation, pipelines in redis-plus-plus have the following characteristics</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: By default, creating a Pipeline object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>This is clearly a downside in the API as pipelines should be the default way of communicating and not an exception, paying such a high price for each pipeline imposes a severe cost in performance. Transactions also suffer from the very same problem.</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: Creating a Transaction object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>In Aedis there is no difference between sending one command, a pipeline or a transaction because requests are decoupled from the IO objects.</p>
<blockquote class="doxtable">
<p >&zwj;redis-plus-plus also supports async interface, however, async support for Transaction and Subscriber is still on the way.</p>
<p >The async interface depends on third-party event library, and so far, only libuv is supported. </p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_redis = AsyncRedis(opts, pool_opts);</div>
<div class="line"> </div>
<div class="line">Future&lt;string&gt; ping_res = async_redis.ping();</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; ping_res.get() &lt;&lt; endl;</div>
</div><!-- fragment --><p> As the reader can see, the async interface is based on futures which is also known to have a bad performance. The biggest problem however with this async design is that it makes it impossible to write asynchronous programs correctly since it starts an async operation on every command sent instead of enqueueing a message and triggering a write when it can be sent. It is also not clear how are pipelines realised with this design (if at all).</p>
<p ><a class="anchor" id="api-reference"></a> </p>
<h1><a class="anchor" id="autotoc_md21"></a>
Reference</h1>
<ul>
<li><a class="el" href="group__high-level-api.html">High-Level</a>: Covers the topics discussed in this document.</li>
<li><a class="el" href="group__low-level-api.html">Low-Level</a>: Covers low-level building blocks. Provided mostly for developers, users won't usually need any information provided here.</li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
Installation</h1>
<p >Download the latest release on <a href="https://github.com/mzimbres/aedis/releases">https://github.com/mzimbres/aedis/releases</a>. Aedis is a header only library, so you can starting using it right away by adding the <code>include</code> subdirectory to your project and including</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;aedis/src.hpp&gt;</span></div>
</div><!-- fragment --><p >in no more than one source file in your applications. To build the examples and tests cmake is supported, for example</p>
<div class="fragment"><div class="line">BOOST_ROOT=/opt/boost_1_80_0 cmake --preset dev</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md23"></a>
Acknowledgement</h1>
<p >Acknowledgement to people that helped shape Aedis</p>
<ul>
<li>Richard Hodges (<a href="https://github.com/madmongo1">madmongo1</a>): For very helpful support with Asio, the design of asynchronous programs, etc.</li>
<li>Vincius dos Santos Oliveira (<a href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful discussion about how Aedis consumes buffers in the read operation.</li>
<li>Petr Dannhofer (<a href="https://github.com/Eddie-cz">Eddie-cz</a>): For helping me understand how the <code>AUTH</code> and <code>HELLO</code> command can influence each other.</li>
<li>Mohammad Nejati (<a href="https://github.com/ashtum">ashtum</a>): For pointing out scenarios where calls to <code>async_exec</code> should fail when the connection is lost.</li>
<li>Klemens Morgenstern (<a href="https://github.com/klemens-morgenstern">klemens-morgenstern</a>): For useful discussion about timeouts, cancellation, synchronous interfaces and general help with Asio.</li>
<li>Vinnie Falco (<a href="https://github.com/vinniefalco">vinniefalco</a>): For general suggestions about how to improve the code and the documentation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Changelog</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
v1.4.0-1</h2>
<ul>
<li>Renames <code>retry_on_connection_lost</code> to <code>cancel_if_unresponded</code>. (v1.4.1)</li>
<li>Removes dependency on Boost.Hana, boost::string_view, Boost.Variant2 and Boost.Spirit.</li>
<li>Fixes build and setup CI on windows.</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
v1.3.0-1</h2>
<ul>
<li>Upgrades to Boost 1.80.0</li>
<li>Removes automatic sending of the <code>HELLO</code> command. This can't be implemented properly without bloating the connection class. It is now a user responsibility to send HELLO. Requests that contain it have priority over other requests and will be moved to the front of the queue, see <code><a class="el" href="classaedis_1_1resp3_1_1request.html#structaedis_1_1resp3_1_1request_1_1config" title="Request configuration options.">aedis::resp3::request::config</a></code></li>
<li>Automatic name resolving and connecting have been removed from <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code>. Users have to do this step manually now. The reason for this change is that having them built-in doesn't offer enough flexibility that is need for boost users.</li>
<li>Removes healthy checks and idle timeout. This functionality must now be implemented by users, see the examples. This is part of making Aedis useful to a larger audience and suitable for the Boost review process.</li>
<li>The <code>aedis::connection</code> is now using a typeddef to a <code>net::ip::tcp::socket</code> and <code>aedis::ssl::connection</code> to <code>net::ssl::stream&lt;net::ip::tcp::socket&gt;</code>. Users that need to use other stream type must now specialize <code><a class="el" href="classaedis_1_1basic__connection.html" title="A connection to the Redis server.">aedis::basic_connection</a></code>.</li>
<li>Adds a low level example of async code.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
v1.2.0</h2>
<ul>
<li><code>aedis::adapt</code> supports now tuples created with <code>std::tie</code>. <code>aedis::ignore</code> is now an alias to the type of <code>std::ignore</code>.</li>
<li>Provides allocator support for the internal queue used in the <code>aedis::connection</code> class.</li>
<li>Changes the behaviour of <code>async_run</code> to complete with success if asio::error::eof is received. This makes it easier to write composed operations with awaitable operators.</li>
<li>Adds allocator support in the <code><a class="el" href="classaedis_1_1resp3_1_1request.html" title="Creates Redis requests.">aedis::resp3::request</a></code> (a contribution from Klemens Morgenstern).</li>
<li>Renames <code>aedis::resp3::request::push_range2</code> to <code>push_range</code>. The suffix 2 was used for disambiguation. Klemens fixed it with SFINAE.</li>
<li>Renames <code>fail_on_connection_lost</code> to <code><a class="el" href="classaedis_1_1resp3_1_1request.html#aab978e56c202631d2fea293b73725e69" title="If true aedis::connection::async_exec will complete with error if the connection is lost....">aedis::resp3::request::config::cancel_on_connection_lost</a></code>. Now, it will only cause connections to be canceled when <code>async_run</code> completes.</li>
<li>Introduces <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a4054811af1ac8f14a04a501907bc05be" title="If true the request will complete with aedis::error::not_connected if async_exec is called before the...">aedis::resp3::request::config::cancel_if_not_connected</a></code> which will cause a request to be canceled if <code>async_exec</code> is called before a connection has been established.</li>
<li>Introduces new request flag <code>aedis::resp3::request::config::retry</code> that if set to true will cause the request to not be canceled when it was sent to Redis but remained unresponded after <code>async_run</code> completed. It provides a way to avoid executing commands twice.</li>
<li>Removes the <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> overload that takes request and adapter as parameters.</li>
<li>Changes the way <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> behaves with <code>std::vector&lt;<a class="el" href="structaedis_1_1resp3_1_1node.html" title="A node in the response tree.">aedis::resp3::node</a>&lt;T&gt;&gt;</code>. Receiving RESP3 simple errors, blob errors or null won't causes an error but will be treated as normal response. It is the user responsibility to check the content in the vector.</li>
<li>Fixes a bug in <code>connection::cancel(operation::exec)</code>. Now this call will only cancel non-written requests.</li>
<li>Implements per-operation implicit cancellation support for <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">aedis::connection::async_exec</a></code>. The following call will <code>co_await (conn.async_exec(...) || timer.async_wait(...))</code> will cancel the request as long as it has not been written.</li>
<li>Changes <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> completion signature to <code>f(error_code)</code>. This is how is was in the past, the second parameter was not helpful.</li>
<li>Renames <code>operation::receive_push</code> to <code><a class="el" href="group__high-level-api.html#ggadcfe42e0996c05d14fe5f8bacce384bcacbd71f0d3114139d38a8d080d610e5fd" title="Refers to connection::async_receive operations.">aedis::operation::receive</a></code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
v1.1.0-1</h2>
<ul>
<li>Removes <code>coalesce_requests</code> from the <code>aedis::connection::config</code>, it became a request property now, see <code><a class="el" href="classaedis_1_1resp3_1_1request.html#a253cef2ca5d60b1b319019fafb3d27b3" title="If true the request will be coalesced with other requests, see https://redis.io/topics/pipelining....">aedis::resp3::request::config::coalesce</a></code>.</li>
<li>Removes <code>max_read_size</code> from the <code>aedis::connection::config</code>. The maximum read size can be specified now as a parameter of the <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> function.</li>
<li>Removes <code>aedis::sync</code> class, see intro_sync.cpp for how to perform synchronous and thread safe calls. This is possible in Boost. 1.80 only as it requires <code>boost::asio::deferred</code>.</li>
<li>Moves from <code>boost::optional</code> to <code>std::optional</code>. This is part of moving to C++17.</li>
<li>Changes the behaviour of the second <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> overload so that it always returns an error when the connection is lost.</li>
<li>Adds TLS support, see intro_tls.cpp.</li>
<li>Adds an example that shows how to resolve addresses over sentinels, see subscriber_sentinel.cpp.</li>
<li>Adds a <code>aedis::connection::timeouts::resp3_handshake_timeout</code>. This is timeout used to send the <code>HELLO</code> command.</li>
<li>Adds <code>aedis::endpoint</code> where in addition to host and port, users can optionally provide username, password and the expected server role (see <code>aedis::error::unexpected_server_role</code>).</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">aedis::connection::async_run</a></code> checks whether the server role received in the hello command is equal to the expected server role specified in <code>aedis::endpoint</code>. To skip this check let the role variable empty.</li>
<li>Removes reconnect functionality from <code>aedis::connection</code>. It is possible in simple reconnection strategies but bloats the class in more complex scenarios, for example, with sentinel, authentication and TLS. This is trivial to implement in a separate coroutine. As a result the <code>enum event</code> and <code>async_receive_event</code> have been removed from the class too.</li>
<li>Fixes a bug in <code>connection::async_receive_push</code> that prevented passing any response adapter other that <code>adapt(std::vector&lt;node&gt;)</code>.</li>
<li>Changes the behaviour of <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">aedis::adapt()</a></code> that caused RESP3 errors to be ignored. One consequence of it is that <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> would not exit with failure in servers that required authentication.</li>
<li>Changes the behaviour of <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> that would cause it to complete with success when an error in the <code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> occurred.</li>
<li>Ports the buildsystem from autotools to CMake.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
v1.0.0</h2>
<ul>
<li>Adds experimental cmake support for windows users.</li>
<li>Adds new class <code>aedis::sync</code> that wraps an <code>aedis::connection</code> in a thread-safe and synchronous API. All free functions from the <code>sync.hpp</code> are now member functions of <code>aedis::sync</code>.</li>
<li>Split <code>aedis::connection::async_receive_event</code> in two functions, one to receive events and another for server side pushes, see <code>aedis::connection::async_receive_push</code>.</li>
<li>Removes collision between <code>aedis::adapter::adapt</code> and <code>aedis::adapt</code>.</li>
<li>Adds <code>connection::operation</code> enum to replace <code>cancel_*</code> member functions with a single cancel function that gets the operations that should be cancelled as argument.</li>
<li>Bugfix: a bug on reconnect from a state where the <code>connection</code> object had unsent commands. It could cause <code>async_exec</code> to never complete under certain conditions.</li>
<li>Bugfix: Documentation of <code><a class="el" href="group__high-level-api.html#gac56bb1a8df93445853a4b9dae2d97b6e" title="Creates an adapter that ignores responses.">adapt()</a></code> functions were missing from Doxygen.</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
v0.3.0</h2>
<ul>
<li>Adds <code>experimental::exec</code> and <code>receive_event</code> functions to offer a thread safe and synchronous way of executing requests across threads. See <code>intro_sync.cpp</code> and <code>subscriber_sync.cpp</code> for examples.</li>
<li><code>connection::async_read_push</code> was renamed to <code>async_receive_event</code>.</li>
<li><code>connection::async_receive_event</code> is now being used to communicate internal events to the user, such as resolve, connect, push etc. For examples see <a class="el" href="cpp20__subscriber_8cpp_source.html">cpp20_subscriber.cpp</a> and <code>connection::event</code>.</li>
<li>The <code>aedis</code> directory has been moved to <code>include</code> to look more similar to Boost libraries. Users should now replace <code>-I/aedis-path</code> with <code>-I/aedis-path/include</code> in the compiler flags.</li>
<li>The <code>AUTH</code> and <code>HELLO</code> commands are now sent automatically. This change was necessary to implement reconnection. The username and password used in <code>AUTH</code> should be provided by the user on <code>connection::config</code>.</li>
<li>Adds support for reconnection. See <code>connection::enable_reconnect</code>.</li>
<li>Fixes a bug in the <code>connection::async_run(host, port)</code> overload that was causing crashes on reconnection.</li>
<li>Fixes the executor usage in the connection class. Before theses changes it was imposing <code>any_io_executor</code> on users.</li>
<li><code>connection::async_receiver_event</code> is not cancelled anymore when <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> exits. This change makes user code simpler.</li>
<li><code><a class="el" href="classaedis_1_1basic__connection.html#a4d7f180e64db5d4e07f7c62b3aa931d4" title="Executes a command on the Redis server asynchronously.">connection::async_exec</a></code> with host and port overload has been removed. Use the other <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> overload.</li>
<li>The host and port parameters from <code><a class="el" href="classaedis_1_1basic__connection.html#a821df744a8c7e63f98e73608329fa1d7" title="Starts read and write operations.">connection::async_run</a></code> have been move to <code>connection::config</code> to better support authentication and failover.</li>
<li>Many simplifications in the <code>chat_room</code> example.</li>
<li>Fixes build in clang the compilers and makes some improvements in the documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
v0.2.0-1</h2>
<ul>
<li>Fixes a bug that happens on very high load. (v0.2.1)</li>
<li>Major rewrite of the high-level API. There is no more need to use the low-level API anymore.</li>
<li>No more callbacks: Sending requests follows the ASIO asynchronous model.</li>
<li>Support for reconnection: Pending requests are not canceled when a connection is lost and are re-sent when a new one is established.</li>
<li>The library is not sending HELLO-3 on user behalf anymore. This is important to support AUTH properly.</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
v0.1.0-2</h2>
<ul>
<li>Adds reconnect coroutine in the <code>echo_server</code> example. (v0.1.2)</li>
<li>Corrects <code>client::async_wait_for_data</code> with <code>make_parallel_group</code> to launch operation. (v0.1.2)</li>
<li>Improvements in the documentation. (v0.1.2)</li>
<li>Avoids dynamic memory allocation in the client class after reconnection. (v0.1.2)</li>
<li>Improves the documentation and adds some features to the high-level client. (v.0.1.1)</li>
<li>Improvements in the design and documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
v0.0.1</h2>
<ul>
<li>First release to collect design feedback. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 14 2023 18:40:26 for Aedis by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
