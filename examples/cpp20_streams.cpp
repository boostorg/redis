/* Copyright (c) 2018-2022 Marcelo Zimbres Silva (mzimbres@gmail.com)
 *
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE.txt)
 */

#include <iostream>
#include <boost/asio.hpp>
#include <boost/redis.hpp>
#include <boost/redis/src.hpp>

#include <memory>
#include <string>
#include <thread>
#include <vector>

namespace net = boost::asio;
using tcp = boost::asio::ip::tcp;

namespace redis = boost::redis;
using redis::operation;
using redis::request;
using boost::redis::generic_response;

void log(boost::system::error_code const& ec, char const* prefix)
{
   std::clog << prefix << ec.message() << std::endl;
}

class redis_client
{
    net::io_context& ioc_;
    tcp::endpoint endpoint_;
    net::ip::tcp::resolver resv_;
    redis::connection conn_;
    std::string redisStreamKey_;

    std::string streamId_;

public:
    redis_client(
        net::io_context& ioc,
        tcp::endpoint endpoint,
        const std::string& redisStreamKey)
        : ioc_(ioc)
        , endpoint_(endpoint)
        , resv_(ioc)
        , conn_(net::make_strand(ioc))
        , redisStreamKey_(redisStreamKey)
        , streamId_("$")
    {
    }

    void resolve()
    {
        resv_.async_resolve(
            endpoint_,
            [this](auto ec, auto results) { this->on_resolve(ec, results); });
    }

private:

    void
    on_run(
        boost::system::error_code ec)
    {
        if (ec) {
            return log(ec, "on_run: ");
        }
    }

    void
    on_connect(
        const boost::system::error_code& ec,
        auto ep)
    {
        if (ec) {
            return log(ec, "on_connect: ");
        }

        conn_.async_run([this](auto ec) { this->on_run(ec); });
        do_exec();
    }

    void on_resolve(
        const boost::system::error_code& ec,
        tcp::resolver::results_type results)
    {
        if (ec) {
            return log(ec, "on_resolve: ");
        }

        net::async_connect(
            conn_.next_layer(),
            results,
            [this](auto ec, auto ep) { this->on_connect(ec, ep); });
    }

    void
    do_exec()
    {
        auto req = this->createStreamRequest();
        auto resp = this->createStreamResponse();

        conn_.async_exec(
            *req,
            *resp,
            [this, req, resp](auto ec, auto size) { this->on_exec(ec, size, req, resp); });
    }

    void on_exec(
        boost::system::error_code ec,
        std::size_t responseSize,
        std::shared_ptr<request> req,
        std::shared_ptr<generic_response> resp)
    {
        try {
            this->on_exec_internal(ec, responseSize, req, resp);
        }
        catch (...) {
        }

        do_exec();
    }

    void
    on_exec_internal(
        boost::system::error_code ec,
        std::size_t responseSize,
        std::shared_ptr<request> req,
        std::shared_ptr<generic_response> resp)
    {
        static const std::string Response_Field_MyField = "myfield";

        if (ec)
        {
            log(ec, "on_exec: ");
            conn_.cancel(operation::run);
            return;
        }

        if (!resp->has_value())
        {
            return;
        }

        // std::cout << "Response: ";
        // for (int i = 0; i < resp->value().size(); ++i) {
        //     std::cout << resp->value().at(i).value << ", ";
        // }
        // std::cout << std::endl;

        // The following approach was taken in order to be able to deal with the responses,
        //  as generated by redis in the case that there are multiple stream 'records' within a single generic_response.
        //  The nesting and number of values in localResp->value() are different, depending on the contents of the stream in redis.
        //  Uncomment the above commented-out code for examples while running the XADD command.

        // "myfield" values don't start before index 4.
        std::size_t itemIndex = 4;
        while (itemIndex < resp->value().size()) {
            const auto& val = resp->value().at(itemIndex).value;

            if (Response_Field_MyField.compare(val) == 0) {
                // We've hit a myfield field.
                //  The streamId is located at itemIndex - 2
                //  The payload is located at itemIndex + 1
                this->streamId_ = resp->value().at(itemIndex - 2).value;
                std::cout << "[" << std::this_thread::get_id() << "] StreamId: " << this->streamId_ << ", MyField: " << resp->value().at(itemIndex + 1).value << std::endl;
                ++itemIndex; // We can increase so we don't read this again
            }

            ++itemIndex;
        }
    }

    std::shared_ptr<request> createStreamRequest()
    {
        auto req = std::make_shared<request>();
        req->push("XREAD", "BLOCK", "0", "STREAMS", this->redisStreamKey_, this->streamId_);
        return req;
    }

    std::shared_ptr<generic_response> createStreamResponse()
    {
        return std::make_shared<generic_response>();
    }
};

std::shared_ptr<redis_client> startRedisClient(
    const std::string& ipAddress,
    unsigned short portNumber,
    const std::string& redisStreamKey,
    boost::asio::io_context& ioc)
{
    auto const address = net::ip::make_address(ipAddress);

    auto redisClient = std::make_shared<redis_client>(
        ioc,
        tcp::endpoint{address, portNumber},
        redisStreamKey);
    redisClient->resolve();
    return redisClient;
}

// Run this in another terminal:
//  redis-cli -r 100000 -i 0.0001 XADD "test-topic" "*" "myfield" "myfieldvalue1"
auto main(int argc, char * argv[]) -> int
{
    try {
        std::string redisHost = "127.0.0.1";
        unsigned short redisPort = 6379;
        int threads = 20;
        std::string redisStreamKey = "test-topic";

        if (argc == 5)
        {
            redisHost = argv[1];
            redisPort = static_cast<unsigned short>(std::atoi(argv[2]));
            threads = std::max<int>(1, std::atoi(argv[3]));
            redisStreamKey = argv[4];
        }

        net::io_context ioc;

        std::cout << "[" << std::this_thread::get_id() << "] Starting redis client on " << redisHost << ":" << redisPort << std::endl;
        auto redisClient = startRedisClient(redisHost, redisPort, redisStreamKey, ioc);

        // Run the I/O service on the requested number of threads
        std::vector<std::thread> v;
        v.reserve(threads - 1);
        for(auto i = threads - 1; i > 0; --i) {
            v.emplace_back(
            [&ioc] {
                ioc.run();
            });
        }
        ioc.run();

        return 0;
    }
    catch (std::exception const &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 1;
}
